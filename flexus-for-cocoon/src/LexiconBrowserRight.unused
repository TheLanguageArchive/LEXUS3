<?xml version="1.0" encoding="utf-8"?>
<mx:TabNavigator xmlns:mx="http://www.adobe.com/2006/mxml"
				 xmlns:mpi="nl.mpi.lexus.*" 
				 xmlns:flexiframe="http://code.google.com/p/flex-iframe/"
				 id="rightTabNav" width="75%" height="100%"
				 creationPolicy="all" change="rightTabChanged(event)"
				 backgroundAlpha="0.0">
	
	<mx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import components.CustomTextArea2;
			
			import flash.sampler.getInvocationCount;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ICollectionView;
			import mx.collections.IViewCursor;
			import mx.containers.Grid;
			import mx.containers.GridItem;
			import mx.containers.GridRow;
			import mx.containers.HBox;
			import mx.containers.Panel;
			import mx.containers.TabNavigator;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.TextArea;
			import mx.controls.VideoDisplay;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.Container;
			import mx.core.FlexGlobals;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.core.UITextField;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.events.IndexChangedEvent;
			import mx.events.ListEvent;
			import mx.events.MenuEvent;
			import mx.events.StateChangeEvent;
			import mx.events.VideoEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.rpc.events.ResultEvent;
			
			import nl.mpi.lexus.LexiconTreeItemRenderer;
			import nl.mpi.lexus.LexusUtil;
			import nl.mpi.lexus.YesNo;
			import nl.mpi.lexus.event.ImportCompleteEvent;
			import nl.mpi.lexus.event.NewLexiconEvent;
			import nl.mpi.lexus.service.LexusService;

			private var videoDisplay:VideoDisplay = null;
			
			private var instanceDataElements:Array = null;
			[Bindable] private var instanceDataElementsList:Array = null;
			[Bindable] private var editable:Boolean = false;
			private var editorWidgets:Array = null;
			private var currentSelectedWidget:UIComponent = null;
			private var lastTmpId:int = 0;
			
			private var lexusService:LexusService = new LexusService();
			private var resourceReference:FileReference = new FileReference();
			/**
			 * This variable is used to check whether there is a lexicalEntry to be saved.
			 **/
			private var saveLexicalEntryTarget:Object = null;
			
			private var mediaWindow:MediaWindow = null;
			
			private var initialColorLevel:int = 170;
			
			private var requestActive:Boolean = false;			
			
			private var schemaIndex:Object = new Object();
			
			private var listTreeVisibility:String = "list";
			
			/**
			 * The title of the panel, suitably shortened if necessary.
			 **/
			private var maxTitleLength:int = 140;
			
			/**
			 * A place to save an event. In case we need to save some data
			 *  while processing an event we park the event here.
			 **/
			private var originalEvent:Event;
			
			/*
			 * A place to save the name of a function after confirmSaveLexicalEntry.
			 */
			private var functionAfterConfirmSave:Function = null;
			
			/* Use searchTerm after a small period of inactivity */
			private var searchTermTimer:Timer = null;
			/**
			 *  For moving data back and forth to the external HTML input (I think).
			 */
			//private var currentPatternInput:DynamicTextInput;
			
			
			private function init():void {		
			}
			
			public function openLexicon(a_lexiconId:String):void {
				LexusUtil.showWait(this, "Loading entries");
				this._loadUserData();
				this._openLexicon( a_lexiconId, "", "", 0, LEXICAL_ENTRIES_PER_PAGE);
			}
			private function _loadUserData():void{
				(new LexusService()).send( "getUserData.json", null, this.name, onJSONLoadUserData);
			}
			private function onJSONLoadUserData(event:ResultEvent):void {
				
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						FlexGlobals.topLevelApplication.lexusUser = data.result;
					}
				);
				
			}		
			private function _openLexicon(a_lexiconId:String, a_startLetter:String, a_searchTerm:String, a_startPage:int, a_pageSize:int):void {
				var parameter:Object = new Object();
				parameter.lexicon = a_lexiconId;
				var refinerObj:Object = new Object();
				refinerObj.startPage = a_startPage;
				refinerObj.pageSize = a_pageSize;
				refinerObj.startLetter = a_startLetter;
				refinerObj.searchTerm = a_searchTerm;
				parameter.refiner = refinerObj;
				FlexGlobals.topLevelApplication.lexiconId = a_lexiconId;
				lexusService.send("LexusLexicalEntryEditor/startLetterSearch.json", parameter, this.name, onJSONLoad);
			}
			/**
			 * Event Handler for the onLoad event. This will load the JSON object and perform initial initialization
			 * */
			private function onJSONLoad(event:ResultEvent):void
			{
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						if (null != data.status) {
							if (null != data.status.success) {
								if (data.status.success == true) {
									preprocessData(data);
									serverData = data;
									sessionId = serverData.result.sessionID;
									createSchemaIdIndex(serverData.result.mySchema);
									resetTreeAndEditor();
									_init();
								}
								else if (null != data.status.message) {
									YesNo.alert("Oops... an error occurred. Server says: " + data.status.message);
								}
								else {
									YesNo.alert("Oops... server flagged an error but did not return a message to explain the error. That sucks.");
								}
							}
							else {
								YesNo.alert("Oops... server did not indicate success or failure of the last operation. Bummer. That's no good. Sorry about that. Assume your last action failed.");
							}
						}		
						else {
							YesNo.alert("Oops... server returned no status! This can't be good. Assume your last action failed.");
						}
						LexusUtil.removeWait();
						FlexGlobals.topLevelApplication.enabled = true;
					}
				);
			}
			
			/**
			 * Create an index on schema ID.
			 * For every schema node the child nodes are loaded into
			 * the "children" property.
			 **/
			private function createSchemaIdIndex(schema:Array):void {
				schemaIndex = new Object();
				createSchemaIdIndexForNode(schema, schema);
			}
			
			/**
			 * Create an index on schema ID for every node in the schema.
			 **/
			private function createSchemaIdIndexForNode(node:Array, schema:Array):void {
				for( var i:int = 0; i < node.length; i++) {
					schemaIndex[node[i].id] = node[i];
					schemaIndex[node[i].id].children = loadSchemaChildren(node[i].id, schema);
				}
			}
			
			/**
			 * Return the children of schemaElementId.
			 **/
			private function loadSchemaChildren(schemaElementId:String, schema:Array):Array{
				var result:Array = new Array();
				for( var i:int = 0; i < schema.length; i++){
					if( schema[i].parent == schemaElementId)
						result[result.length]= schema[i];
					
				}
				return result;
			}
			
			/**
			 * Get a node of the schema by ID.
			 **/
			public function getSchemaNodeById(id:String):Object {
				return schemaIndex[id];
			}
			
			
			private function resetTreeAndEditor():void{
				this.tree.dataProvider = null;
			}
			private function _init():void{
				initializePageList();
				if( (dgList.dataProvider as ArrayCollection).length >0){
					dgList.selectedIndex = 0;
					doSwitchEntry();           			
				}
				this.initalizeStartLetterList();
				this.initializeLexicaList();
				this.initializeQueryList();
				this.initializePageNavigation();
				this.initializeQueryBuilder();
				dgList.validateNow();
				dgList.validateDisplayList();
				this.initializeEditor();
				FlexGlobals.topLevelApplication.moduleInitialised("lexicon_browser");

			}
			
			private function preprocessData(jsonData:Object):void {
				if (jsonData.result.myResult && jsonData.result.myResult.lexicalEntries) {
					var entries:ArrayCollection = new ArrayCollection(jsonData.result.myResult.lexicalEntries);
					for( var i:int = 0; i < entries.length; i++){
						var listView:Object = entries.getItemAt(i).listView;
						listView.value = this.transformListView(listView.value);
					}
				}
			}
			
			private function transformListView(listViewHTML:String):String{
				if( listViewHTML == null)
					return "";
				
				var txt:String = listViewHTML;
				
				/** AAM: Here, we need to do a replace the matching regular expressions as many times as needed. 
				 * e.g. the 1st replace can generate new '&amp;' regular expresions if we have: '&amp;amp'
				 * on the original 'txt' string.
				 * */
				
				var ampPattern:String = "\&amp;";
				var ltPattern:String = "\&lt;";
				var gtPattern:String = "\&gt;";
				var qtPattern:String = "\&quot;";
				
				while (txt.indexOf(ampPattern) != -1)
					txt  =txt.replace(ampPattern, "&");
				while (txt.indexOf(ltPattern) != -1)
					txt = txt.replace(ltPattern, "<");
				while (txt.indexOf(gtPattern) != -1)
					txt  =txt.replace(gtPattern, ">");
				while (txt.indexOf(qtPattern) != -1)
					txt  =txt.replace(qtPattern, "'");
		
				return txt;
			}
			
			private function initializeLexicaList():void{
				var lexicon:Object = serverData.result.myResult.lexicon;
				serverData.result.lexica.unshift({
					"id": "",
					"name": "<switch lexicon>"
				});
				var lexica:ArrayCollection = new ArrayCollection(serverData.result.lexica);
				for (var i:int = 0; i < lexica.length; i++) {
					var lx:Object = lexica.getItemAt(i);
					lx.name = LexusUtil.cutOffString(lx.name, 40);
				}
			}
			private function initializeQueryList():void{
				var emptyQuery:Object = new Object();
				emptyQuery.name="<filter>";
				var queries:ArrayCollection = new ArrayCollection( this.serverData.result.queries);
				var queriesList:ArrayCollection = new ArrayCollection();
				for( var i:int = 0; i< queries.length; i++)
					queriesList.addItem( queries.getItemAt(i));									
				queriesList.addItemAt( emptyQuery, 0);
				this.querySelect.dataProvider = queriesList;
				if( this.serverData.result.query != null){
					var qId:String = this.serverData.result.query.id;
					
					for( var j:int =0; j < queriesList.length; j++){
						var query:Object = queriesList.getItemAt(j);
						if( query.id == qId){
							this.querySelect.selectedIndex = j;
							break;
						}
					}					
				}
				
			}
			
			
			private function initalizeStartLetterList():void {
				var startLetter:String = serverData.result.myResult.startLetter;
				serverData.result.startLetters.splice(0, 0, {"label":"-","value":""});
				var startLetters:ArrayCollection = new ArrayCollection(serverData.result.startLetters);
				for(var i:int = 0; i < startLetters.length; i++) {
					var startLetterObj:Object = startLetters.getItemAt(i);
					
					
					
					if( startLetterObj.label == startLetter){
						startLetterList.selectedIndex = i;
						break;
					}
				}
			}
			
			/**
			 * Initializes the QueryBuilder to work with the current lexicon for this LexiconBrowser.
			 * This will cause the AddQueryElement to work on a single lexicon only. So queries constructed
			 * here always use the same (one) lexicon
			 **/ 
			private function initializeQueryBuilder():void{
				var lexicon:Object = this.serverData.result.myResult.lexicon;
				this.queryBuilder.lexicon = lexicon;
			}
			private function initializePageNavigation():void{
				var startPage:int = this.serverData.result.myResult.startPage;
				if( startPage == 0){
					this.navPrevPage.enabled = false;
					this.navFirstPage.enabled = false;
				}
				else{
					this.navPrevPage.enabled = true;
					this.navFirstPage.enabled = true;
				}
				this.initializePageList();
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				if( startPage == (totalPages -1)){
					this.navNextPage.enabled = false;
					this.navLastPage.enabled = false;
				}
				else{
					this.navNextPage.enabled = true;
					this.navLastPage.enabled = true;
				}				
			}
			
			
			private function initializePageList():void {
				var startPage:int = this.serverData.result.myResult.startPage;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				var pageList:ArrayCollection = new ArrayCollection();
				var index:int = 0;
				for( var i:int = 0; i < totalPages; i++){
					var page:Object = new Object();
					page.label = "" + (i+1);
					page.value = i;
					pageList.addItem( page);
					if( page.value == startPage)
						index = i;
				}
				this.pageList.dataProvider = pageList;
				this.pageList.selectedIndex = index;
			}
			
			/**
			 * Handles the change event on the left tabs
			 * */
			private function leftTabChanged(evt:IndexChangedEvent):void{
				this.queryBuilder.requestSave();
				
				this.lexicalEntryView.enabled = true;
				this.lexicalEntryEditor.enabled = true;
				var tabNav:TabNavigator = evt.target as TabNavigator;
				if ((mx.containers.Canvas) (tabNav.selectedChild).id != "listView"){
					showSelectedEntry();
					rightTabNav.selectedChild = lexicalEntryEditor;
					iFrame.visible = false;
				}
				else if( tabNav.selectedChild == queryBuilder){
					this.lexicalEntryView.enabled = false;
					this.lexicalEntryEditor.enabled = false;
				}
			}
			
			/**
			 * Handles the change event in the list
			 **/
			private function switchEntry(event: MouseEvent): void {
				if (this.saveLexicalEntryTarget != null) {
					this.functionAfterConfirmSave = doSwitchEntry;
					this.confirmLexicalEntrySave(doSwitchEntry);
					return;
				}
				doSwitchEntry();
			}
			
			/**
			 * Performs all updates related to changes in the currently selected entry from the list
			 **/
			private function doSwitchEntry():void {				
				if (rightTabNav.selectedChild == lexicalEntryEditor) {
					showSelectedEntry();	
					iFrame.visible = false;
					dgList.setFocus();
				}
				else if (dgList.selectedItem!=null) {
					LexusUtil.showWait(this, "Loading lexical entry data");					
					var param:Object = new Object();
					param.id = dgList.selectedItem.id;
					param.lexicon = serverData.result.myResult.lexicon.id;
					this.lexusService.send("LexusLexicalEntryEditor/getLexicalEntryData.json", param, this.name, onLexicalEntryReload);
					dgList.setFocus();
				}		
			}
			
			
			/**
			 * Displays the information for the tooltip of the selected item in the left tree 
			 **/ 
			private function treeToolTip(item:Object):String{
				var report:Object = reportOnDataNode(item);
				var message:String = "";
				var i:int;
				if (report.errors.length > 0) {
					for (i = 0; i<report.errors.length ; i++) {
						message += report.errors[i] + "\n";
					}
				}
				else if (report.warnings.length > 0) {
					for (i = 0; i<report.warnings.length ; i++) {
						message += report.warnings[i] + "\n";
					}
				}
				else {
					message = item.value;
				}
				return message;
			}		
			
			
			/**
			 * Handles the click events in the left tree. Populates the list of acive schema elements 
			 * for the currently selected tree instance node
			 **/
			private function treeItemClicked(evt:ListEvent):void {					
				this.displayInstanceElement();	
			}
			
			/**
			 * Requests a confirmation from the user to save the changes.
			 * 
			 **/ 
			private function confirmLexicalEntrySave(afterwards:Function = null):void {
				YesNo.confirmSave("Do you want to save your changes?", confirmLexicalEntrySaveHandler(afterwards));
			}
			
			/**
			 * Handles the user response to the save request presented to the user
			 **/ 
			private function confirmLexicalEntrySaveHandler(afterwards:Function = null):Function {
				var me:LexiconBrowser = this;
				return function (event:CloseEvent):void {
					FlexGlobals.topLevelApplication.enabled  = false;
					if (event.detail == Alert.YES) {
						LexusUtil.showWait(me, "Saving entry");					
						var param:Object = new Object();
						param.lexicalEntry  = me.saveLexicalEntryTarget;
						param.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
						me.lexusService.send("LexusLexicalEntryEditor/saveLexicalEntry.json", param, me.name, onLexicalEntryReloadWithAfterwards(afterwards));
					} 
					else {
						LexusUtil.showWait(me, "Reloading entry");					
						var param1:Object = new Object();
						param1.id = me.saveLexicalEntryTarget.id;
						param1.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
						me.lexusService.send("LexusLexicalEntryEditor/getLexicalEntryData.json", param1, me.name, onLexicalEntryReloadWithAfterwards(afterwards));
					}
					me.saveLexicalEntryTarget = null;
				};
			}
			
			/*
			 * Process the loading event and call afterwards().
			 */
			private function onLexicalEntryReloadWithAfterwards(afterwards:Function = null):Function {
				return function (event:ResultEvent):void {
					onLexicalEntryReload(event);
					
					/**
					 * If the lexical entry was saved or reloaded again and the original handler needs to be called,
					 * call it now that all data has been processed on the server and updated in the client.
					 **/
					if (afterwards != null) {
						afterwards();
					}
				};
			}
			
			private function onLexicalEntryReload(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						if (data.status.success == false) {
							YesNo.alert(data.status.message);					
						}
						else if (data.status.success == true) {
							data.result.lexicalEntry.listView.value = transformListView(data.result.lexicalEntry.listView.value);
							var coll:ICollectionView = (dgList.dataProvider as ICollectionView);
							var cursor:IViewCursor = coll.createCursor();
							var refresh:Boolean = (data.result.lexicalEntry.id == dgList.selectedItem.id);
							while (!cursor.afterLast){
								if (cursor.current.id == data.result.lexicalEntry.id){
									cursor.remove();
									cursor.insert( data.result.lexicalEntry);
									if (refresh){
										dgList.selectedItem = data.result.lexicalEntry;
										showSelectedEntry();
									}
									break;
								}
								cursor.moveNext();
							}
						}
						LexusUtil.removeWait();
						callLater(dgList.setFocus);
						if (originalEvent != null) {
							FlexGlobals.topLevelApplication.menuBar.dispatchEvent(originalEvent);
							originalEvent = null;
						}
						FlexGlobals.topLevelApplication.enabled = true;
					}
				);
				lexicalEntryView.enabled = true;
				TreeEditor.enabled = true;
			}
			
			/**
			 * Get schema children of a node. If you already have the schemaElement you can supply it,
			 * otherwise, it will be looked up.
			 **/ 
			public function getSchemaChildren(node:Object, schemaElement:Object = null):Array {
				if (null == schemaElement) {
					schemaElement = getSchemaNodeById(node.schemaElementId);
				}
				var schemaChildren:Array = schemaElement.children;
				schemaChildren = this.filterMultipleAllowed(schemaChildren, node);
				return schemaChildren;
			}
			
			private function displayInstanceElement():void {	
				var idx:int = dgList.selectedIndex;
				var selectedNode:Object = tree.selectedItem;
				var schemaElement:Object = this.getSchemaNodeById(selectedNode.schemaElementId);
				if (schemaElement.type != "data category"){
					this.multimediaTab.enabled = false;
					this.displayDataCategory( schemaElement);
					this.displayNotes( selectedNode, false);
				}
				
				var schemaChildren:Array = getSchemaChildren(selectedNode, schemaElement);
				activeSchemaElements.dataProvider = schemaChildren.sortOn(["type", "name"], Array.CASEINSENSITIVE);
				if(schemaChildren.length > 0)
					schemaElementsPanel.enabled = true;
				else
					schemaElementsPanel.enabled = false;
				
				if (entryEditors.selectedChild == TreeEditor) {
					var widget:UIComponent = this.editorWidgets[tree.selectedItem.id]
					
					if( TreeEditor.verticalScrollBar!=null && TreeEditor.verticalScrollBar.visible){
						var p:Point = new Point( widget.x, widget.y);
						p = widget.localToGlobal( p);
						var p1:Point = TreeEditor.globalToLocal(p); 
						TreeEditor.verticalScrollPosition += p1.y;
					}
					
					callLater(widget.setFocus);
				}
			}
			/**
			 *Filters out the schemaElements from the specified array for which only one instance is allowed and which
			 * is already present in the specified currentInstance
			 *
			 **/  
			private function filterMultipleAllowed( a_schemaElements:Array, a_currentInstance:Object):Array{
				var result:ArrayCollection = new ArrayCollection();
				for( var i:int = 0; i < a_schemaElements.length; i++){
					
					if( a_schemaElements[i].max == 1){
						//Check here whether it is already present in the currentInstance
						var children:ArrayCollection = new ArrayCollection( a_currentInstance.children);
						var found:Boolean = false;
						for( var j:int = 0; j < children.length; j++){
							var child:Object = children.getItemAt(j);
							if( child.schemaElementId == a_schemaElements[i].id){
								found = true;
								break;
							}
						}
						if( !found)
							result.addItem( a_schemaElements[i]);
					}
					else
						result.addItem( a_schemaElements[i]);
				}
				return result.toArray();
			}
			/**
			 * Handles the drag enter event for the tree
			 **/
			private function onTreeDragEnter(evt:DragEvent):void{
				var dropTarget:AutoSizeTree = AutoSizeTree(evt.currentTarget);
				var uiComp:IUIComponent = evt.dragInitiator;
				if( uiComp == activeSchemaElements && evt.dragSource.hasFormat( "items")){
					DragManager.showFeedback(DragManager.MOVE);
					DragManager.acceptDragDrop(dropTarget);
				}
				else {
					DragManager.showFeedback(DragManager.NONE);
					return;     	
				}
			}
			/**
			 * Handles the drag over event on the tree
			 **/
			private function onTreeDragOver( evt:DragEvent):void{
				evt.preventDefault();
				evt.currentTarget.showDropFeedback(evt);
				
				var dropTarget:AutoSizeTree = AutoSizeTree(evt.currentTarget);
				var r:int = dropTarget.calculateDropIndex(evt);
				tree.selectedIndex = r;
				var actSchemaElements:Array =evt.dragSource.dataForFormat("items") as Array;
				//if the activeSchemaElements from list does not match the id of the current item in tree return
				var dropEnabled:Boolean = true;
				for( var i:int = 0; i < actSchemaElements.length; i++){
					if( actSchemaElements[i].parent != tree.selectedItem.schemaElementId){
						dropEnabled = false;
						break;
					}
					
				}
				
				if( dropEnabled){
					DragManager.showFeedback(DragManager.MOVE);
					DragManager.acceptDragDrop(dropTarget);
				}
				else{
					DragManager.showFeedback(DragManager.NONE);
					return;
				}
				
			}
			/**
			 * Handles the drag drop event on the tree
			 **/
			private function onTreeDragDrop(evt: DragEvent):void{
				evt.preventDefault();
				evt.currentTarget.hideDropFeedback(evt);
				var dropTarget:AutoSizeTree =AutoSizeTree(evt.currentTarget);   
				var r:int = dropTarget.calculateDropIndex(evt);
				tree.selectedIndex = r;
				var actSchemaElements:Array =evt.dragSource.dataForFormat("items") as Array;
				for( var i:int = 0; i < actSchemaElements.length; i++){
					this.insertTreeNode(actSchemaElements[i]);
				}
				this.displayInstanceElement();
				this.markLexicalEntrySavePoint();
				
			}
			
			private function addSchemaElementToComponent(schemaElement:Object):void {
				if(activeSchemaElements.selectedItem != null){ 
					insertTreeNode(schemaElement);
					displayInstanceElement();
					markLexicalEntrySavePoint();
				}
				
			}
			private function generateTemporaryId():String{
				this.lastTmpId++;
				return "_tmp" + this.lastTmpId;
			}
			/**
			 * Inserts a new instance based on the specified schemaElement specification under the currently
			 * selected node in the tree
			 **/
			private function insertTreeNode(schemaElement:Object):void{
				var instanceElement:Object = new Object();
				instanceElement.id= this.generateTemporaryId();
				
				instanceElement.label=schemaElement.name;
				instanceElement.value = "";
				instanceElement.notes="";
				instanceElement.multimedia=null;
				instanceElement.schemaElementId=schemaElement.id;
				if( schemaElement.type != "data category")
					instanceElement.children=[];
				var children:ArrayCollection = new ArrayCollection(tree.selectedItem.children);
				children.addItemAt( instanceElement, 0);
				tree.invalidateDisplayList();
				tree.invalidateList();
				initializeEditor();
			}
			
			private function removeLIU(event:MouseEvent):void{
				var liu:Object = this.tree.selectedItem;
				var parent:Object = this.tree.getParentItem(liu);
				if (null != parent) {
					var children:ArrayCollection = new ArrayCollection( parent.children);
					children.removeItemAt( children.getItemIndex( liu));
					this.tree.invalidateDisplayList();
					this.tree.invalidateList();
					initializeEditor();
					this.saveLexicalEntryTarget = this.dgList.selectedItem;
				}
			}
			/**
			 * Returns the icon class for the specified schemaElement. This method is used by the List 
			 * of currently active schema elements to determine the icons associated with the schema elements
			 **/
			private function getElementIconClass( schemaElement:Object):Class{
				if( schemaElement.type =="data category")
					return this.dataCategoryIconClass;
				else
					return this.containerIconClass; 
				
				return null;
			}
			/**
			 * Shows the selected entry from the list
			 **/
			private function showSelectedEntry():void{
				if( dgList.selectedItem == null) 
					return;
				if( !dgList.selectedItem.hasOwnProperty("children")){
					TreeEditor.enabled = false;
					LexusUtil.showWait(this, "Loading lexical entry data");					
					var param:Object = new Object();
					param.id = dgList.selectedItem.id;
					param.lexicon = serverData.result.myResult.lexicon.id;
					this.lexusService.send("LexusLexicalEntryEditor/getLexicalEntryData.json", param, this.name, onLexicalEntryReload); 
					return;
				}	
				tree.dataProvider = dgList.selectedItem;
				if( rightTabNav.selectedChild == lexicalEntryEditor)
					initializeEditor();
				callLater(expandTree);
				tree.validateNow();
				tree.selectedIndex = 0;
				if( rightTabNav.selectedChild == lexicalEntryEditor)
					this.displayInstanceElement();
				else
					loadLEV(dgList.selectedItem.entryView);
			}
			
			private function expandTree():void{
				tree.expandChildrenOf( dgList.selectedItem, true);
			}
			
			/**
			 * Handles the events for changing the start letter
			 **/
			private function changeStartLetter(evt:ListEvent):void{
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				var startLetter:String = "";
				if( this.startLetterList.selectedIndex != 0)
					startLetter = this.startLetterList.selectedItem.label;
				LexusUtil.showWait(this, "Loading entries");
				this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, 0, LEXICAL_ENTRIES_PER_PAGE);
			}
			
			/**
			 * Handles the events for changing the start letter
			 **/
			private function changeSearchTerm(event:Event):void{
				if (searchTermTimer == null) {
					searchTermTimer = new Timer(SEARCHTERMTIMERDELAY, 1);
					searchTermTimer.addEventListener(TimerEvent.TIMER, searchTermTimerHandler);
				}
				searchTermTimer.reset();
//				if (searchTerm.text != "") {
					searchTermTimer.delay = SEARCHTERMTIMERDELAY;
					searchTermTimer.start();
//				}
			}
			private function searchTermTimerHandler(event:Event):void {
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				
				var searchTerm:String = searchTerm.text;
				LexusUtil.showWait(this, "Loading entries");
				this._openLexicon( this.serverData.result.myResult.lexicon.id, "", searchTerm, 0, LEXICAL_ENTRIES_PER_PAGE);
			}
			/**
			 * Handles the event for changing lexica
			 **/
			private function changeLexica(evt:ListEvent):void {
				if (lexicaList.selectedItem.id != "") {
					iFrame.visible = false;
					FlexGlobals.topLevelApplication.enabled  = false;
					openLexicon(lexicaList.selectedItem.id);
				}
			}
			
			/**
			 * Handles the event for changing List vs Tree view
			 **/
			private function changeListTreeView(evt:MouseEvent):void {
				if (listAndTree.selectedChild == latList) {
					listAndTree.selectedChild = latTree;
					changeViewButton.label = "Switch to list view";
				}
				else {
					listAndTree.selectedChild = latList;
					changeViewButton.label = "Switch to structure view";
				}
			}
			
			private function onQueryChange(event:ListEvent):void {
				FlexGlobals.topLevelApplication.enabled  = false;
				LexusUtil.showWait(this, "Loading entries");					
				if (querySelect.selectedItem.id == null) {
					_openLexicon(serverData.result.myResult.lexicon.id, "", "", 0, LEXICAL_ENTRIES_PER_PAGE);
				}
				else { 	
					_executeQuery(querySelect.selectedItem, serverData.result.myResult.lexicon, "", 0, LEXICAL_ENTRIES_PER_PAGE);
				} 	
				return;
			}
			
			private function _executeQuery(a_query:Object, a_lexicon:Object, a_startLetter:String, a_startPage:int, a_pageSize:int):void{
				var parameter:Object = new Object();
				parameter.query = a_query;
				
				
				var refinerObj:Object = new Object();
				refinerObj.lexicon = a_lexicon;
				refinerObj.startPage = a_startPage;
				refinerObj.pageSize = a_pageSize;
				refinerObj.startLetter = a_startLetter;
				parameter.refiner = refinerObj;
				lexusService.send("LexusLexicalEntryEditor/startLetterQuerySearch.json", parameter, this.name, onJSONLoadQueryChange);
				
			}
			
			private function onJSONLoadQueryChange(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function (data:Object):void {
						if (data.status && data.status.success && data.status.success == true) {
							preprocessData(data);
							serverData = data;
							_init();
						}
						else {
							YesNo.alert("Oops...");
						}
						LexusUtil.removeWait();
						FlexGlobals.topLevelApplication.enabled  = true;
					}
				);	
			}
			/**
			 * Handles the navigate up button event
			 **/
			private function navigateUp(event:Event):void {				
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateUp2);
					return;
				}
			}
			private function navigateUp2():void {
				var index:int = dgList.selectedIndex;
				
				if( index < (dgList.dataProvider.length-1))
					index ++;
				dgList.selectedIndex=index;
				doSwitchEntry();
				dgList.scrollToIndex(index);
			}
			/**
			 * Handles the navigate down button event
			 **/
			private function navigateDown(event:Event):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateDown2);
					return;
				}
			}
			private function navigateDown2():void {
				var index:int = dgList.selectedIndex;
				if( index >0)
					index --;
				dgList.selectedIndex=index;
				doSwitchEntry();
				
				dgList.scrollToIndex(index);
			}
			
			/**
			 * Handles the event for navigating to the first page
			 **/
			private function navigateToFirstPage(event:MouseEvent):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateToFirstPage2);
					return;
				}
			}
			private function navigateToFirstPage2():void {
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				LexusUtil.showWait(this, "Loading entries");
				if( this.serverData.result.query != null) {
					this._executeQuery(this.serverData.result.query, this.serverData.result.myResult.lexicon, this.startLetterList.selectedItem.label, 0, LEXICAL_ENTRIES_PER_PAGE);
				}
				else
					this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, 0, LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			
			/**
			 * Handles the event for navigating to the last page
			 **/
			private function navigateToLastPage(event:MouseEvent):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateToLastPage2);
					return;
				}
			}
			private function navigateToLastPage2():void {
				FlexGlobals.topLevelApplication.enabled  = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				LexusUtil.showWait(this, "Loading entries");
				if( this.serverData.result.query != null) {
					this._executeQuery(this.serverData.result.query, this.serverData.result.myResult.lexicon, this.startLetterList.selectedItem.label, (totalPages-1), LEXICAL_ENTRIES_PER_PAGE);
				}
				else
					this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, (totalPages -1), LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			/**
			 * Handles the event for navigating to the previous page
			 **/
			private function navigateToPreviousPage(event:MouseEvent):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateToPreviousPage2);
					return;
				}
			}
			private function navigateToPreviousPage2():void {
				var startPage:int = this.serverData.result.myResult.startPage;
				if( startPage >0){
					FlexGlobals.topLevelApplication.enabled  = false;
					iFrame.visible = false;
					var startLetter:String = this.serverData.result.myResult.startLetter;
					LexusUtil.showWait(this, "Loading entries");					
					if( this.serverData.result.query != null)
						this._executeQuery(this.serverData.result.query, this.serverData.result.myResult.lexicon, this.startLetterList.selectedItem.label, (startPage-1), LEXICAL_ENTRIES_PER_PAGE);
					else
						this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, (startPage -1), LEXICAL_ENTRIES_PER_PAGE);
					dgList.setFocus();
				}
			}
			/**
			 * Handles the event for navigating to the next page
			 **/
			private function navigateToNextPage(event:MouseEvent):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(navigateToNextPage2);
					return;
				}
			}
			private function navigateToNextPage2():void {
				var startPage:int = this.serverData.result.myResult.startPage;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				if( startPage < totalPages){
					FlexGlobals.topLevelApplication.enabled  = false;
					iFrame.visible = false;
					var startLetter:String = this.serverData.result.myResult.startLetter;
					LexusUtil.showWait(this, "Loading entries");					
					if( this.serverData.result.query != null) {
						this._executeQuery(this.serverData.result.query, this.serverData.result.myResult.lexicon, this.startLetterList.selectedItem.label, (startPage+1), LEXICAL_ENTRIES_PER_PAGE);
					}
					else
						this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, (startPage + 1), LEXICAL_ENTRIES_PER_PAGE);
					dgList.setFocus();
				}
			}
			/**
			 * Handles the event for navigating to another result page
			 **/
			private function changePage(event: ListEvent):void {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave(changePage2);
					return;
				}
			}
			private function changePage2(event: ListEvent):void {
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				LexusUtil.showWait(this, "Loading entries");					
				if( this.serverData.result.query != null)
					this._executeQuery( this.serverData.result.query, this.serverData.result.myResult.lexicon, startLetter, this.pageList.selectedItem.value, LEXICAL_ENTRIES_PER_PAGE);		
				else
					this._openLexicon( this.serverData.result.myResult.lexicon.id, startLetter, searchTerm.text, this.pageList.selectedItem.value, LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			/**
			 * Handles the event for changing the tab on the top right side
			 **/
			private function rightTabChanged( evt:IndexChangedEvent):void{
				if (rightTabNav.selectedChild == lexicalEntryEditor){
					showSelectedEntry();	
					iFrame.visible = false;
				}
				else if (dgList.selectedItem != null){
					loadLEV(dgList.selectedItem.entryView);
					dgList.setFocus();
				} 
			}
			
			/**
			 * Handles the event for changing the tab on the bottom right side
			 **/			
			private function propertyTabChanged( evt:IndexChangedEvent):void{				
			}
			
			private function editorChanged(event:IndexChangedEvent):void {
				if (entryEditors.selectedChild == TreeEditor) {
					if (instanceDataElements.length == 0) {
						var data:Object = dgList.selectedItem;
						_initializeTreeEditor(data, TreeEditor, editable, initialColorLevel);
					}
				}
			}
			
			/**
			 * Handles the event for key down event for the list
			 **/
			private function keyHandler(event:KeyboardEvent):void
			{
				switch( event.keyCode){
					case 38: doSwitchEntry();
						break;
					case 40: doSwitchEntry();
						break;
				}
			}
			
			
			private function initializeEditor():void{
				var data:Object = dgList.selectedItem;
				TreeEditor.removeAllChildren();
				editorWidgets = new Array();
				instanceDataElements = new Array();
				instanceDataElementsList = new Array();
				editable = serverData.result.myResult.lexicon.writable;
				removeLexicalEntryButton.visible = editable;
				queryBuilder.addBTN.visible = editable;
				queryBuilder.removeBTN.visible = editable;
				queryBuilder.modifyBTN.visible = editable;
				newLexicalEntryButton.visible = editable;
				schemaElementsPanel.visible = editable;
				removeElementButton.visible = editable;
				_initializeListEditor(data, editable);
				
			}
			
			private function getColor( r:int, g:int, b:int):String{
				return "0x" + fixedInt(rgbToInt(r, g, b), '000000'); 
			}
			private function fixedInt(value:int, mask:String):String {
				return String(mask + value.toString(16)).substr(-mask.length).toUpperCase();
			}
			
			private function rgbToInt(r:int, g:int, b:int):int {
				return r << 16 | g << 8 | b << 0;
			}
			
			
			private function _initializeListEditor(object:Object, isEditable:Boolean): void {
				if (object == null)
					return;
				
				if (object.hasOwnProperty("children")) {
					for( var i:int = 0; i < object.children.length; i++){
						_initializeListEditor(object.children[i], isEditable);
					}
				}
				else if ((this.getSchemaNodeById(object.schemaElementId) != null) {
					if (this.instanceDataElementsList == null) {
						this.instanceDataElementsList = new Array;
					}
					this.instanceDataElementsList.push(object);
				}
			}
			
			private function _initializeTreeEditor(object:Object, parentContainer:Container, isEditable:Boolean, colorLevel:int):void {
				if (object == null)
					return;
				this.instanceDataElements[object.id] = object;
				
				if( object.hasOwnProperty("children") || (this.getSchemaNodeById(object.schemaElementId) != null && this.getSchemaNodeById(object.schemaElementId).type != "data category")){
					var parentCont:Container = null;
					if( parentContainer is GridRow){
						parentCont = new GridItem();
						parentCont.percentWidth = 100;
						(parentCont as GridItem).colSpan = 2;
						parentContainer.addChild( parentCont);
					}
					else
						parentCont = parentContainer;
					var panel:Panel = new Panel();
					this.editorWidgets[object.id]=panel;
					panel.title = object.label;
					panel.percentWidth=100;
					panel.percentHeight=100;
					panel.setStyle("paddingTop", 10);
					panel.setStyle( "paddingLeft", 20);
					panel.setStyle( "paddingBottom", 5);
					
					var colorStr:String = this.getColor( colorLevel, colorLevel, colorLevel);
					panel.setStyle("backgroundColor", colorStr);
					
					var grid:Grid = new Grid();
					grid.percentWidth = 100;
					grid.percentHeight = 100;            		
					panel.addChild(grid);
					if (object.children != null){
						for( var i:int = 0; i < object.children.length; i++){
							var row:GridRow = new GridRow();
							row.percentHeight=100;
							row.percentWidth=100;
							colorLevel =((colorLevel+8>255)? this.initialColorLevel:colorLevel +8);
							_initializeTreeEditor( object.children[i], row, isEditable, colorLevel);
							grid.addChild( row);
						}
					}
					parentCont.addChildAt(panel, 0);
				}
				else{
					var gridItem1:GridItem = new GridItem();
					gridItem1.percentWidth=100;
					var label:Label = new Label();
					label.text = object.label;
					gridItem1.addChild( label);
					gridItem1.percentWidth = 30;
					
					/**
					 *AAM: Icon handeling. 
					 * Displays an icon at the end of the datacategory name, indicating the multimedia type
					 * atached to that datacategory (if there is multimedia atached). 
					 **/ 
					
					if (object.multimedia != null){
						var icon:Image = new Image();
						
						switch (object.multimedia.type) {
							case "image":
								icon.source = ("images/camera.png");
								break;
							case "video":
								icon.source = ("images/film.png");
								break;
							case "audio":
								icon.source = ("images/sound.png");
								break;
							case "url":
								icon.source = ("images/link.png");
								break;
							default:
								trace("Cannot find multimedia icon. Unknown data type!");
								break;
						}

					icon.alpha =0.9;
					icon.width = 16;
					gridItem1.addChild( icon);
					}
					
					
					var gridItem2:GridItem = new GridItem();
					gridItem2.percentWidth = 70;
					if( object.valuedomain == null){
						//var edit:TextArea = new TextArea();
						var edit:CustomTextArea2 = new CustomTextArea2();
						edit.percentWidth = 100;
						edit.percentHeight = 100;
						edit.id = object.id;
						this.editorWidgets[object.id]=edit;
						
						edit.text = object.value;
						edit.editable = isEditable;
						var emptyValueIndicator:Function =  
							function():void { // Change background color to orange as a warning.
								if (edit.text == "") {
									edit.setStyle("backgroundColor", "#FFAA00");
								}
								else {
									edit.setStyle("backgroundColor", "#FFFFFF");            			  		
								}
							};
						emptyValueIndicator();
						edit.addEventListener(FocusEvent.FOCUS_IN , displayProperties);
						edit.addEventListener(Event.CHANGE, onContentChange);
						edit.addEventListener(Event.CHANGE, emptyValueIndicator);
						gridItem2.addChild( edit);
					}
					else{
						var cBox:ComboBox = new ComboBox;
						var list:ArrayCollection = new ArrayCollection();
						for( var j:int = 0; j < object.valuedomain.length; j++){
							var item:Object = new Object();
							item.label = object.valuedomain[j];
							item.data = null;
							list.addItem( item);
						}
						cBox.dataProvider = list;
						cBox.id = object.id;
						cBox.editable = isEditable;
						this.editorWidgets[object.id]=cBox;
						cBox.addEventListener(FocusEvent.FOCUS_IN , displayProperties);
						cBox.addEventListener(ListEvent.CHANGE, onContentChange);
						
						gridItem2.addChild( cBox); 
					}
					parentContainer.addChild( gridItem1);
					parentContainer.addChild( gridItem2);
				}
			}
			
			private function onContentChange( event:Event):void{
				this.markLexicalEntrySavePoint();
				var widget:UIComponent = (event.target as UIComponent);
				
				if( widget is TextArea){
					var selObj:Object = this.instanceDataElements[ widget.id];
					selObj.value = (widget as TextArea).text;
				}
				else if( widget is ComboBox){
					var selObj1:Object = this.instanceDataElements[ widget.id];
					selObj1.value = (widget as ComboBox).selectedItem;
				}
			}
			
			private function markLexicalEntrySavePoint():void{
				this.saveLexicalEntryTarget = this.dgList.selectedItem;
			}
			private function displayProperties(evt:FocusEvent):void{
				
				var uiComp:UIComponent = evt.currentTarget as UIComponent;
				this.currentSelectedWidget = uiComp;
				var dataElement:Object = this.loadDataElement( uiComp.id);
				var media:UIComponent = null;
				this.displayMultiMedia( dataElement.multimedia, dataElement.value, this.serverData.result.myResult.lexicon.writable);
				var schemaElement:Object = this.getSchemaNodeById( dataElement.schemaElementId);
				this.displayDataCategory( schemaElement);
				this.displayNotes( dataElement, this.serverData.result.myResult.lexicon.writable);
			}
			
			private function displayDataCategory( data:Object):void{
				this.dataCategoryTab.label = "Properties";
				dc_name.text = data.name;
				dc_description.text = data.description;
				dc_adminInfo.text = data.adminInfo;
				var mandatory:Boolean = (data.min=="0"?false:true);
				dc_mandatory.selected = mandatory;
				var multiples:Boolean = (data.max=="1"?false:true);
				dc_multiples.selected = multiples;
				var valDom:ArrayCollection = new ArrayCollection( data.valuedomain);
				
				
				if( valDom.length > 0){
					var text:String = "";
					for( var i:int = 0; i < valDom.length; i++){
						text += valDom.getItemAt( i);
						if( i != valDom.length -1)
							text += ", ";
					}
					dc_valuedomain.text = text;
				}
				else
					dc_valuedomain.text = "<Any>"
			}
			private function displayMultiMedia(multiMedia:Object, label:String, editable:Boolean):void{
				multimediaTab.enabled = true;
				mediaPanel.visible = false;
				this.importMM_button1.enabled = editable;
				this.importMM_button2.enabled = editable;
				this.importMM_button3.enabled = editable;
				this.importMM_button4.enabled = editable;
				this.importMM_button5.enabled = editable;
				imagePanel.visible = false;
				videoPanel.visible = false;
				audioPanel.visible = false;
				uploadPanel.visible = false;
				importPanel.visible = false;
				urlPanel.visible = false;
				if( currentSoundChannel != null)
					currentSoundChannel.stop();
				currentSound = null;
				currentSoundChannel = null;
				currentSoundPosition = 0;
				
				if( multiMedia == null){
					importPanel.visible = true;
					return;
				}
				//We will hit this point when the mediaWindow is closed and the properties are redisplayed. We don't want to open it again automatically at this point
				var openNewWindow:Boolean = true;
				if( this.mediaWindow != null){
					
					if( multiMedia.url =="" || multiMedia.url != this.mediaWindow.currentSource){
						this.mediaWindow.closeWindow();
						
					}
					else
						openNewWindow = false;
					//return;
				}
				
				switch (multiMedia.type) {
					case "image":
						image.source = multiMedia.url;
						imagePanel.visible = true;
						break;
					case "video":
						if( openNewWindow){
							openAudioVideoWindow( multiMedia, label);
						}
						mediaPanel.visible = true;
						videoPanel.visible = true;
						break;
					case "audio":
						if( openNewWindow)
							openAudioVideoWindow( multiMedia, label);						
						mediaPanel.visible = true;
						videoPanel.visible = true;
						break;
					case "upload":
						uploadPanel.visible = true;
						break;
					case "url":
						urlPanel.visible = true;
						break;
					default:
						importPanel.visible = true;
						break;
				}
			}
			
			private function openAudioVideoWindow( multiMedia:Object, label:String):void{
				var globalPt:Point = new Point( 500, 400);
				var localPt:Point = this.globalToLocal( globalPt);
				
				this.mediaWindow = MediaWindow( PopUpManager.createPopUp( this, MediaWindow, true));
				this.mediaWindow.title = label;
				this.mediaWindow.x = localPt.x;
				this.mediaWindow.y = localPt.y;
				this.mediaWindow.currentSource = multiMedia.url;
			}
			
			
			private var currentSound:Sound = null;
			private var currentSoundChannel:SoundChannel = null;
			private var currentSoundPosition:int =0;
			private function playSound():void{
				if( currentSound != null){
					currentSoundChannel = currentSound.play(currentSoundPosition);
				}
			} 
			private function pauseSound():void{
				if( currentSoundChannel != null){
					currentSoundPosition = currentSoundChannel.position;
					trace( "currentSoundPosition=" + currentSoundPosition);
					currentSoundChannel.stop();
				}
				
			}
			
			private function stopSound():void{
				currentSoundPosition = 0;
				if( currentSoundChannel!=null)
					currentSoundChannel.stop();	
			}
			
			private function videoStateChange( evt:VideoEvent):void{
				trace("statechange");
			}
			
			private function displayNotes(data:Object, editable:Boolean):void{
				this.notes.enabled = editable;
				notes.text = data.notes;
			}
			
			private function loadDataElement( id:String):Object{
				return _loadDataElement( id, dgList.selectedItem);
			}
			private function _loadDataElement( id:String, data:Object):Object{
				if( data.id == id)
					return data;
				
				var result:Object = null;
				if( data.hasOwnProperty("children")){
					for( var i:int = 0; i < data.children.length; i++){
						result = _loadDataElement( id, data.children[i]);
						if( result != null)
							break;
					}
				}
				return result;
			}
			
			
			/**
			 * Event handler for the Menu control's click event.
			 **/
			public function onMenuSelect(event:MenuEvent):Boolean  {
				var handled:Boolean = true;
				var url:String;
				var popExport:FileDownloadBox;
				this.originalEvent = null;
				var evtName:String = event.item.@eventName;
				
				if (evtName == "save") {
					save();
					return true;
				}
				
				/** Request Save actions for other menu items, if necessary.
				 *  If something needs saving, store the original event so that it can
				 *  be dispatched again after the save.
				 **/
				if (requestSave()) {
					this.originalEvent = event;
					return true;
				}
				
				switch (evtName) {
					case "import_shbx":
						var popShbxImport:ShbxImport = ShbxImport(PopUpManager.createPopUp(this,ShbxImport,true));
						popShbxImport.importLexiconId = serverData.result.myResult.lexicon.id;
						popShbxImport.existingLexicon = true;
						popShbxImport.sessionId = sessionId;
						popShbxImport.addEventListener("new", handleLexiconImport);
						PopUpManager.centerPopUp(popShbxImport);
						popShbxImport.y = 20;
						break;
					case "schema_editor":
						iFrame.visible = false;
						FlexGlobals.topLevelApplication.lexiconId = serverData.result.myResult.lexicon.id; 
						handled = false;
						break;
					case "workspace": case "about":
						iFrame.visible = false;
						handled = false;
						break;
					case "export_xml":
						url = lexusService.getAbsoluteURL("XMLexport.zip?id="+serverData.result.myResult.lexicon.id);
						//navigateToURL(new URLRequest(url),"_blank");
						popExport = FileDownloadBox(PopUpManager.createPopUp(this, FileDownloadBox, false));
						popExport.theUrl = url;
						//popExport.sessionId = sessionId;
						PopUpManager.centerPopUp(popExport);
						break;                	
					case "export_midi":
						url = lexusService.getAbsoluteURL("Archive/getImdiArchiveObject.json?id="+serverData.result.myResult.lexicon.id);
						//navigateToURL(new URLRequest(url),"_blank");
						popExport = FileDownloadBox(PopUpManager.createPopUp(this, FileDownloadBox, false));
						popExport.theUrl = url;
						//popExport.sessionId = sessionId;
						PopUpManager.centerPopUp(popExport);
						break;
					default:
						handled = false;
						break;
				}
				return handled;
			}
			
			/* Save unsaved data, called from menu event handler or keyboard handler */
			public function save():void {           	
				if( this.saveLexicalEntryTarget != null){
					FlexGlobals.topLevelApplication.enabled  = false;
					LexusUtil.showWait(this, "Saving entry");					
					var param:Object = new Object();
					param.lexicalEntry  = this.saveLexicalEntryTarget;
					// param.schema = this.serverData.result.mySchema;
					param.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
					this.saveLexicalEntryTarget = null;
					this.lexusService.send("LexusLexicalEntryEditor/saveLexicalEntry.json", param, this.name, onLexicalEntryReload);
				}
				if (queryBuilder.saveNeeded()) {
					queryBuilder.save();
				}
			}
			
			//Request Save actions for other menu items, if necessary.
			private function requestSave():Boolean {
				if (this.saveLexicalEntryTarget != null) {
					this.confirmLexicalEntrySave();
					return true;
				}
				if (this.queryBuilder.requestSave()) {
					return true;	
				}            	
				return false;
			}    
			
			private function handleLexiconImport(event:NewLexiconEvent):void {
			}
			
			private function zoomImage( evt:MouseEvent):void{
				
				if( this.currentSelectedWidget != null){
					var dataElement:Object = this.loadDataElement( this.currentSelectedWidget.id);
					if( dataElement.multimedia != null){
						switch(dataElement.multimedia.type){
							case "image":
								var popImage:ImageZoom = ImageZoom(PopUpManager.createPopUp(this,ImageZoom,true));
								var glbPt:Point = new Point( 100, 100);
								var lclPt:Point = this.globalToLocal( glbPt);
								popImage.x = lclPt.x;
								popImage.y = lclPt.y;
								popImage.title = dataElement.value;
								popImage.source = dataElement.multimedia.url;
								PopUpManager.centerPopUp(popImage);
								break;
							case "video": 
								this.openAudioVideoWindow(dataElement.multimedia, dataElement.value);
								break;
							case "audio":
								this.openAudioVideoWindow(dataElement.multimedia, dataElement.value);
								break;
							case "url":
								ExternalInterface.call( "window.open", dataElement.multimedia.url);
								break;
						}
					}
				}
			} 
			
			private function getListView( item:Object, column:DataGridColumn):String{
				return item.listView.value;
			}
			
			private function importResource():void{
				var popImport:ImportResourceWindow = ImportResourceWindow(PopUpManager.createPopUp(this,ImportResourceWindow,true));
				popImport.sessionId = this.serverData.result.sessionID;
				popImport.source = this.currentSelectedWidget.id;
				popImport.addEventListener( "complete", this.importResourceComplete);
				PopUpManager.centerPopUp(popImport);
				return;		
			}
			
			
			private function importResourceComplete( event:ImportCompleteEvent):void{
				
				var multiMedia:Object = new Object();
				multiMedia.type="upload";
				multiMedia.archive = event.archive;
				multiMedia.value = event.resourceId;
				multiMedia.fragmentIdentifier = event.fragmentIdentifier;
				multiMedia.url = event.url;
				this.instanceDataElements[event.source].multimedia = multiMedia;
				this.displayMultiMedia( this.instanceDataElements[event.source].multimedia, this.instanceDataElements[event.source].value, this.serverData.result.myResult.lexicon.writable);
				this.markLexicalEntrySavePoint();
			}
			/**
			 * Event handler for the cancel event on the resource browse window.
			 **/ 
			private function resourceCancelHandler( event:Event):void{
				FlexGlobals.topLevelApplication.enabled  = true;
			}
			/**
			 * Event handler for when a user has selected a resource to upload
			 **/
			private function resourceSelectHandler(event:Event):void {
				var fileRef:FileReference = FileReference(event.target);
				var cookie:String = this.serverData.result.sessionID;
				var uploadURLdata:URLRequest = new URLRequest("StagingFileHandler/uploadFile.json;jsessionid=" + cookie);
				var variables:URLVariables = new URLVariables();
				variables.requestId = this.currentSelectedWidget.id;
				uploadURLdata.data = variables;
				
				fileRef.addEventListener(Event.COMPLETE, completeHandler);
				fileRef.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,resourceUploadCompleteDataHandler);
				fileRef.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
				fileRef.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
				fileRef.addEventListener(ProgressEvent.PROGRESS, progressHandler);
				fileRef.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				
				fileRef.upload(uploadURLdata, "resource");
			}
			private function resourceUploadCompleteDataHandler(event:DataEvent):void {
				trace("resource uploadCompleteData: " + event);
				FlexGlobals.topLevelApplication.enabled  = true;
				var rawData:String = String(event.data);
				var result:Object = (JSON.decode(rawData) as Object).result;
				var resourceFileStagingID:String = result.resource; //data is the field specified in the dataFileREf.upload request
				if( this.instanceDataElements[result.requestId].multimedia == null)
					this.instanceDataElements[result.requestId].multimedia = new Object();
				this.instanceDataElements[result.requestId].multimedia.value=resourceFileStagingID;
				this.instanceDataElements[result.requestId].multimedia.type="upload";
				if( this.tree.selectedItem == this.instanceDataElements[result.requestId])
					this.displayMultiMedia( this.tree.selectedItem.multimedia, this.tree.selectedItem.value, this.serverData.result.myResult.lexicon.writable);
				
				this.markLexicalEntrySavePoint();
			}
			private function completeHandler(event:Event):void {
				trace("completeHandler: " + event);
			}
			private function httpStatusHandler(event:HTTPStatusEvent):void {
				trace("httpStatusHandler: " + event);
			}
			
			private function ioErrorHandler(event:IOErrorEvent):void {
				trace("ioErrorHandler: " + event);
			}
			private function progressHandler(event:ProgressEvent):void {
				var file:FileReference = FileReference(event.target);
				trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				trace("securityErrorHandler: " + event);
			}
			
			private function convert( str:String):String{
				var myPattern:RegExp = /\//g;
				return str.replace(myPattern, "/");
			}
			private function updateNote():void{
				this.markLexicalEntrySavePoint();
				this.instanceDataElements[this.currentSelectedWidget.id].notes = this.notes.text;
			}
			private function removeLexicalEntry(event:MouseEvent):void{
				YesNo.confirmDelete("Are you sure you want to remove this entry?", confirmDeleteEntryHandler);
			}
			private function confirmDeleteEntryHandler( event:CloseEvent):void{
				if (event.detail == Alert.YES) {
					var param:Object = new Object();
					param.lexicon = serverData.result.myResult.lexicon.id;
					param.lexicalEntry = dgList.selectedItem;
					this.lexusService.send("LexusLexicalEntryEditor/deleteLexicalEntry.json", param, this.name, onDeleteEntryResult);	
				} 
				
			}
			private function onDeleteEntryResult(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						var id:String = data.result.id;
						var entries:ArrayCollection = dgList.dataProvider as ArrayCollection;
						for( var i:int = 0; i < entries.length; i++){
							var entry:Object = entries.getItemAt(i);
							if( entry.id == id){
								entries.removeItemAt(i);
								dgList.invalidateDisplayList();
								dgList.invalidateList();
								if(saveLexicalEntryTarget == entry)
									saveLexicalEntryTarget = null;
								break;
							}
						}
					}
				);
			}
			
			private function createLexicalEntry():void{
				var parameter:Object = new Object();
				parameter.id=serverData.result.myResult.lexicon.id;
				parameter.lexicon=serverData.result.myResult.lexicon.id;
				lexusService.send("LexusLexicalEntryEditor/createLexicalEntry.json", parameter, this.name, onJSONLoadNewLexicalEntry);
			}
			
			private function onJSONLoadNewLexicalEntry(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						var entry:Object = data.result.lexicalEntry;
						entry.listView.value = transformListView(entry.listView.value);
						(dgList.dataProvider as ArrayCollection).addItem(entry);
						dgList.selectedItem = entry;
						doSwitchEntry();
					}
				);
			}
			
			
			/**
			 * Get a report with errors and warnings on a datanode.
			 * Returns {"errors", ["error message", ...], "warnings", ["warning message",...]} otherwise.
			 * The message arrays can be empty of course. 
			 **/
			public function reportOnDataNode(data:Object):Object {
				var report:Array = [];
				var schemaNode:Object = getSchemaNodeById(data.schemaElementId);
				if (schemaNode != null) {
					var children:Array = schemaNode.children;
					
					report = report.concat(checkCardinality(data, schemaNode, children));
					report = report.concat(checkEmptyValue(data));
				}
				
				/**
				 * Convert the array of messages to a convenient object
				 * with errors apart from warnings.
				 **/
				var reportObject:Object = new Object();
				reportObject.warnings = [];
				reportObject.errors = [];
				for each (var item:Object in report) { 
					if (item.warning)
						reportObject.warnings.push(item.warning);
					if (item.error)
						reportObject.errors.push(item.error);
				} 
				return reportObject;
			}
			
			/**
			 * Returns [] if the value of data element is not "".
			 * Returns [{"warning": "message"}, ...] otherwise.
			 **/
			private function checkEmptyValue(data:Object):Array {
				var report:Array = [];
				
				if (null != data.value && data.value == "")
					report.push({"warning": "The field is empty."});
				return report;
			}
			
			/**
			 * Returns [] if the data element conforms to cardinality in the schema.
			 * Returns [{"error": "errormessage"}, ...] otherwise.
			 **/
			private function checkCardinality(data:Object, schemaNode:Object, children:Array):Array {
				var report:Array = [];
				
				for (var i:int = 0; i < children.length; i++) {
					var child:Object = children[i];
					if (child.min != null) {
						if (countDataNodesWithSchemaId(data.children, child.id) < child.min)
							report.push({"error":
								"There should be a minimum of " + child["min"] + " " + child["name"] + " (" + child["description"] + ") nodes."}); 
					}
					if (child["max"] != null) {
						if(countDataNodesWithSchemaId(data["children"], child["id"]) > child["max"] )
							report.push({"error":
								"A maximum of " + child["min"] + " " + child["name"] + " (" + child["description"] + ") nodes is allowed."});
					}
				}
				return report;
			}
			
			/**
			 * Return the number of data nodes that have the correct schema ID
			 **/			
			private function countDataNodesWithSchemaId(children:Array, schemaId:String):int {
				var count:int = 0;	
				for (var i:int = 0; i < children.length ; i++) {
					if(children[i]["schemaElementId"] == schemaId) {
						count++;
					}
				}
				return count;
			}
			
			private function loadLEV(url:String):void {
				iFrame.source=url;
				iFrame.visible=true;
			}
			
			//Font BugFix
			private var osName:String;
			private var textFont:String;
			
			private function setDefaultFont():void{
				osName = flash.system.Capabilities.os;
				switch(true){
					case (osName.indexOf("Windows") != -1):
						textFont = "Arial Unicode MS";
						break;
					case (osName.indexOf("Mac") != -1):
						textFont = "Lucida Grande";
						break;
					case (osName.indexOf("Linux") != -1):
						textFont = "DejaVu Sans";
						break;
				}
				
					
				
			}				
			
			private function initApp():void{
				// retrieve list of fonts available on user's computer and populate 'Tier text font' combobox
				var allFonts:Array = Font.enumerateFonts(true);
				allFonts.sortOn("fontName", Array.CASEINSENSITIVE);
				
				var fontIndex:int = -1;
				var fontFound:Boolean = false;
				for (var i:uint = 0; i < allFonts.length; i++){
					if (allFonts[i].fontName == textFont){
						fontIndex = i;
						fontFound = true;
						break;
					}
				}
				
				if (!fontFound){	
					textFont = "_sans";		
					// fontChooser.prompt = "Select a font";
				}
				/*
				fontChooser.labelField = "fontName";
				fontChooser.dataProvider = allFonts;
				fontChooser.selectedIndex = fontIndex;
				var fontSize:String = this.styleManager.getStyleDeclaration(".customtext").getStyle("fontSize");
				var fontSizes:ArrayCollection = (this.fontSizeChooser.dataProvider as ArrayCollection);
				for( var j:int = 0; j < fontSizes.length;j++){
					if( fontSizes.getItemAt(j) == fontSize){
						this.fontSizeChooser.selectedIndex = j;
						break;
					}
				} 
				*/
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontFamily", textFont);
				// this.styleManager.getStyleDeclaration(".customtext").setStyle("fontSize", fontSize);
			}
			/*
			private function textFontChanged(evt:ListEvent):void{
				
				textFont = this.fontChooser.selectedItem.fontName;
				var fontSize:Object = this.fontSizeChooser.selectedItem;
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontFamily", textFont);
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontSize", fontSize);

			}		
			*/
		]]>
	</mx:Script>
	
	<mx:Canvas id="lexicalEntryEditor" label="Lexical entry" width="100%"
			   height="100%">
		<!--
		<mx:HBox width="100%" height="22">
			
			<mx:Label text="Font:"/>
			<mx:ComboBox id="fontChooser" top="68" width="200" change="textFontChanged(event)" x="268"/>
			<mx:Label text="Size:"/>
			<mx:ComboBox id="fontSizeChooser" width="60" change="textFontChanged(event)">
				
				<mx:ArrayCollection>
					<mx:int>8</mx:int>
					<mx:int>9</mx:int>
					<mx:int>10</mx:int>
					<mx:int>11</mx:int>
					<mx:int>12</mx:int>
					<mx:int>14</mx:int>
					<mx:int>16</mx:int>
					<mx:int>18</mx:int>
					<mx:int>20</mx:int>
				</mx:ArrayCollection>
				
			</mx:ComboBox>
		</mx:HBox>
		-->
		<mx:VDividedBox width="100%" height="100%" y="0">
			<mx:TabNavigator id="entryEditors" width="100%" height="100%" creationPolicy="all"
							 change="editorChanged(event)">
				<mx:Panel label="List" id="ListEditorPanel">
					<mx:AdvancedDataGrid id="listEditor" width="100%" height="80%"
										 dataProvider="{instanceDataElementsList}" resizableColumns="true"
										 editable="true" sortableColumns="false"
										 itemEditBegin="markLexicalEntrySavePoint();">
						<mx:columns>
							<mx:AdvancedDataGridColumn dataField="label" headerText="Name" editable="false" width="120"/>
							<mx:AdvancedDataGridColumn dataField="value" headerText="Value" editable="{editable}"/>
						</mx:columns>
					</mx:AdvancedDataGrid>
				</mx:Panel>
			<mx:Canvas id="TreeEditor" width="100%" height="80%"
					   verticalScrollPolicy="auto" label="Tree"/>
				</mx:TabNavigator>
			<mx:TabNavigator width="100%" height="20%" creationPolicy="all"
							 change="propertyTabChanged(event)">
				<mx:Canvas id="multimediaTab" label="Multimedia"
						   width="100%" height="100%">
					<mx:Panel id="mediaPanel" title="Video" height="75%"
							  width="75%" horizontalAlign="center" paddingTop="10"
							  paddingLeft="10" paddingRight="10"
							  paddingBottom="10" visible="false">
						<mx:HBox>
							<mx:HBox id="videoPanel" height="75%" width="75%"
									 paddingTop="3" paddingLeft="3" paddingRight="3"
									 paddingBottom="3" visible="true"
									 horizontalAlign="center">
								<mx:Button icon="{zoomIconClass}"
										   click="zoomImage(event)"/>
								<mx:Button id="importMM_button1" label="Modify"
										   click="importResource()"/>
							</mx:HBox>
						</mx:HBox>
					</mx:Panel>
					<mx:VBox id="imagePanel" height="75%" width="75%"
							 paddingTop="3" paddingLeft="3" paddingRight="3"
							 paddingBottom="3" visible="false"
							 horizontalAlign="center">
						<mx:ProgressBar id="imgProgress" source="{image}"
										visible="false" showEffect="Fade"
										hideEffect="Fade"/>
						<mx:HBox width="100%" height="100%">
							<mx:Image id="image" maxHeight="100"
									  maxWidth="300" horizontalAlign="center"
									  completeEffect="Fade"
									  open="{imgProgress.visible=true}"
									  complete="{imgProgress.visible=false}"/>
							<mx:Button icon="{zoomIconClass}"
									   click="zoomImage(event)"/>
							<mx:Button id="importMM_button2" label="Modify"
									   click="importResource()"/>
						</mx:HBox>
					</mx:VBox>
					<mx:Panel id="audioPanel" title="Audio" height="75%"
							  width="75%" horizontalAlign="center" paddingTop="10"
							  paddingLeft="10" paddingRight="10"
							  paddingBottom="10" visible="false">
						<mx:Text width="75%" color="blue"
								 text="Use the buttons to control the audio. The Stop button resets the audio to the beginning."/>
						<mx:HBox>
							<mx:Button label="Play" click="playSound();"/>
							<mx:Button label="Pause" click="pauseSound();"/>
							<mx:Button label="Stop" click="stopSound()"/>
							<mx:Button id="importMM_button3" label="Modify"
									   click="importResource()"/>
						</mx:HBox>
					</mx:Panel>
					<mx:Panel id="uploadPanel" title="File upload"
							  height="75%" width="75%" horizontalAlign="center"
							  paddingTop="10" paddingLeft="10" paddingRight="10"
							  paddingBottom="10" visible="false">
						<mx:VBox>
							<mx:Image
								source="@Embed('../assets/images/icon-download.jpg')"/>
							<mx:Label
								text="This resource has been uploaded but not been activated yet. Please store this entry first...."/>
							<mx:Button label="Modify" click="importResource()"
									   />
						</mx:VBox>
					</mx:Panel>
					<mx:Panel id="importPanel" title="File upload"
							  height="75%" width="75%" horizontalAlign="center"
							  paddingTop="10" paddingLeft="10" paddingRight="10"
							  paddingBottom="10" visible="false">
						<mx:Button id="importMM_button4" label="Import"
								   click="importResource()"/>
					</mx:Panel>
					<mx:HBox id="urlPanel" height="75%" width="75%"
							 paddingTop="3" paddingLeft="3" paddingRight="3"
							 paddingBottom="3" visible="true"
							 horizontalAlign="center">
						<mx:Button icon="{zoomIconClass}"
								   click="zoomImage(event)"/>
						<mx:Button id="importMM_button5" label="Modify"
								   click="importResource()"/>
					</mx:HBox>
				</mx:Canvas>
				<mx:Canvas id="dataCategoryTab" label="Data category"
						   width="100%" height="100%">
					<mx:Grid width="100%">
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Name:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:Text id="dc_name"/>
							</mx:GridItem>
						</mx:GridRow>
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Description:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:Text id="dc_description"/>
							</mx:GridItem>
						</mx:GridRow>
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Admin Info:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:Text id="dc_adminInfo"/>
							</mx:GridItem>
						</mx:GridRow>
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Mandatory:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:CheckBox id="dc_mandatory" enabled="false"/>
							</mx:GridItem>
						</mx:GridRow>
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Multiples allowed:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:CheckBox id="dc_multiples" enabled="false"/>
							</mx:GridItem>
						</mx:GridRow>
						<mx:GridRow>
							<mx:GridItem>
								<mx:Label text="Value domain:"/>
							</mx:GridItem>
							<mx:GridItem>
								<mx:Text id="dc_valuedomain"/>
							</mx:GridItem>
						</mx:GridRow>
					</mx:Grid>
				</mx:Canvas>
				<mx:Panel id="notesTab" label="Notes" width="100%"
						  height="10%" icon="{this.noteIcon}"
						  verticalAlign="bottom" horizontalAlign="left">
					<mx:TextArea id="notes" width="100%" height="100%"
								 change="updateNote()" alpha="0.7"
								 backgroundColor="#FFFF66"/>
				</mx:Panel>
			</mx:TabNavigator>
		</mx:VDividedBox>
	</mx:Canvas>
	<mx:Canvas id="lexicalEntryView" label="Lexical Entry View" width="100%" height="100%">
		<flexiframe:IFrame id="iFrame" x="10" y="10" width="90%" height="90%"/>
	</mx:Canvas>
	<!--
	<mx:Canvas id="vicos" label="Vicos" width="100%" height="100%">
	<mx:ModuleLoader url="modules/Vicos.swf" />
	</mx:Canvas>
	-->
</mx:TabNavigator>
