<?xml version="1.0" encoding="utf-8"?>
<mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:mpi="nl.mpi.lexus.*" xmlns="*" width="100%" height="100%"
		   layout="absolute"
		   creationComplete="setDefaultFont();init();initApp()" 
		   xmlns:local="*"
		   xmlns:flexiframe="http://code.google.com/p/flex-iframe/">
	<mx:Style>
		.customtext{
			/* alternatives: _serif, _typewriter */
			/* font-family:"_sans"; */
			font-size:10;
		}
	</mx:Style>	
	
	<mx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import components.CustomTextArea2;
			
			import flash.sampler.getInvocationCount;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ICollectionView;
			import mx.collections.IViewCursor;
			import mx.containers.Grid;
			import mx.containers.GridItem;
			import mx.containers.GridRow;
			import mx.containers.HBox;
			import mx.containers.Panel;
			import mx.containers.TabNavigator;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.controls.TextArea;
			import mx.controls.VideoDisplay;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.Container;
			import mx.core.FlexGlobals;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.core.UITextField;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.events.IndexChangedEvent;
			import mx.events.ListEvent;
			import mx.events.MenuEvent;
			import mx.events.StateChangeEvent;
			import mx.events.VideoEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ObjectUtil;
			
			import nl.mpi.lexus.LexiconTreeItemRenderer;
			import nl.mpi.lexus.LexusUtil;
			import nl.mpi.lexus.YesNo;
			import nl.mpi.lexus.event.ImportCompleteEvent;
			import nl.mpi.lexus.event.NewLexiconEvent;
			import nl.mpi.lexus.event.QueryEvent;
			import nl.mpi.lexus.service.LexusService;
			
			[Bindable]
			private var application:Object = FlexGlobals.topLevelApplication;
			
			[Bindable] private var serverData:Object = new Object();
			private var videoDisplay:VideoDisplay = null;
			private var sessionId:String = "";
			
			/* The object that contains a modified lexical entry. */
			private var lexicalEntryData:Object = null;
			
			[Bindable][Embed(source="../assets/images/iconza_24x24_0097d9/camera_24x24.png")]private var cameraIcon:Class;
			
			[Bindable][Embed(source="../assets/images/iconza_24x24_0097d9/film_24x24.png")]	private var filmIcon:Class;
			
			[Bindable][Embed(source="../assets/images/iconza_24x24_0097d9/sound_24x24.png")] private var soundIcon:Class;
			
			[Bindable][Embed(source="../assets/images/iconza_24x24_0097d9/globeGray_24x24.png")] private var externalLinkIcon:Class;
			
			[Bindable][Embed(source="../assets/images/iconza_24x24_0097d9/link_24x24.png")] private var internalLinkIcon:Class;	
			
			
			
			private const LEXICAL_ENTRIES_PER_PAGE:Number = 100;
			
			private var instanceDataElements:Array = null;
			private var editorWidgets:Array = null;
			private var currentSelectedWidget:UIComponent = null;
			private var lastTmpId:int = 0;
			
			private var lexusService:LexusService = new LexusService();
			private var resourceReference:FileReference = new FileReference();
			/**
			 * This variable is used to check whether there is a lexicalEntry to be saved.
			 **/
			private var saveLexicalEntryTarget:Object = null;
			
			private var mediaWindow:MediaWindow = null;
			
			private var initialColorLevel:int = 170;
			
			private var requestActive:Boolean = false;			
			
			private var schemaIndex:Object = new Object();
			
			private var listTreeVisibility:String = "list";
			
			/**
			 * The title of the panel, suitably shortened if necessary.
			 **/
			[Bindable] private var maxTitleLength:int = 140;
			
			/**
			 * A place to save an event. In case we need to save some data
			 *  while processing an event we park the event here.
			 **/
			private var originalEvent:MenuEvent;
			
			
			/**
			 * A place to save an switch lexical entry event.
			 **/
			private var originalSwitchEvent:MouseEvent;
			
			
			/**
			 * Initial source for QueryBuilder filters, after setting it in queryBuilder queryBuilder.queries is used.
			 */
			[Bindable] private var queries:Array;
			
			
			/**
			 * source for filter list.
			 */
			[Bindable] private var queriesList:ArrayCollection;

			
			private function init():void {	
				queryBuilder.addEventListener(QueryEvent.ADD, this.handleQueryUpdate);
				queryBuilder.addEventListener(QueryEvent.DELETE, this.handleQueryUpdate);
			}
			
			
			private function handleQueryUpdate(event:Event):void {
				this.initializeQueryList();
			}
			
			public function openLexicon(a_lexiconId:String):void {
				LexusUtil.showWait(this, "Loading entries");
				this._loadUserData();
				FlexGlobals.topLevelApplication.lexiconId = a_lexiconId;
				this._startLetterSearch(0, LEXICAL_ENTRIES_PER_PAGE, a_lexiconId);
			}
			private function _loadUserData():void{
				(new LexusService()).send( "getUserData.json", null, this.name, onJSONLoadUserData);
			}
			private function onJSONLoadUserData(event:ResultEvent):void {
				
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						FlexGlobals.topLevelApplication.lexusUser = data.result;
					}
				);
				
			}
			
			
			private function _startLetterSearch(a_startPage:int, a_pageSize:int, lexiconId:String = ""):void {
				var startLetter:String;
				var parameter:Object = new Object();
				parameter.lexicon = lexiconId == "" ? this.serverData.result.myResult.lexicon.id : lexiconId;
				if (this.startLetterList && this.startLetterList.selectedIndex > 0)
					startLetter = this.startLetterList.selectedItem.label;
				else 
					startLetter = '';
				
				var refinerObj:Object = new Object();
				refinerObj.startPage = a_startPage;
				refinerObj.pageSize = a_pageSize;
				refinerObj.startLetter = startLetter;
				refinerObj.searchTerm = searchTerm ? searchTerm.text : "";
				refinerObj.caseSensitive = caseSensitiveCheckbox ? caseSensitiveCheckbox.selected : false;
				
				if (querySelect != null)
					if (querySelect.selectedItem.id != null)
						parameter.query = querySelect.selectedItem;
				parameter.refiner = refinerObj;
				lexusService.send("LexusLexicalEntryEditor/startLetterSearch.json", parameter, this.name, onJSONLoad);
			}
			
			/**
			 * Event Handler for the onLoad event. This will load the JSON object and perform initial initialization
			 * */
			private function onJSONLoad(event:ResultEvent):void
			{
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						LexusUtil.removeWait();
						FlexGlobals.topLevelApplication.enabled = true;
						if (null != data.status) {
							if (null != data.status.success) {
								if (data.status.success == true) {
									preprocessData(data);
									
									latList.title = data.result.myResult.total + " entr" + (data.result.myResult.total == 1? "y" : "ies") + " found";
									if (data.result.myResult.lexicalEntries) {
										var entries:ArrayCollection = new ArrayCollection(data.result.myResult.lexicalEntries);
										latList.title += entries.length <= 0 ? "" : " (" + entries.length + " shown)";  
									}
										 
									serverData = data;
									queries = data.result.queries;
									sessionId = serverData.result.sessionID;
									createSchemaIdIndex(serverData.result.mySchema);
									resetTreeAndEditor();
									_init();
								}
								else if (null != data.status.message) {
									YesNo.alert("Oops... an error occurred. Server says: " + data.status.message);
								}
								else {
									YesNo.alert("Oops... server flagged an error but did not return a message to explain the error. That sucks.");
								}
							}
							else {
								YesNo.alert("Oops... server did not indicate success or failure of the last operation. Bummer. That's no good. Sorry about that. Assume your last action failed.");
							}
						}		
						else {
							YesNo.alert("Oops... server returned no status! This can't be good. Assume your last action failed.");
						}
					}
				);
			}
			
			/**
			 * Create an index on schema ID.
			 * For every schema node the child nodes are loaded into
			 * the "children" property.
			 **/
			private function createSchemaIdIndex(schema:Array):void {
				schemaIndex = new Object();
				createSchemaIdIndexForNode(schema, schema);
			}
			
			/**
			 * Create an index on schema ID for every node in the schema.
			 **/
			private function createSchemaIdIndexForNode(node:Array, schema:Array):void {
				for( var i:int = 0; i < node.length; i++) {
					schemaIndex[node[i].id] = node[i];
					schemaIndex[node[i].id].children = loadSchemaChildren(node[i].id, schema);
				}
			}
			
			/**
			 * Return the children of schemaElementId.
			 **/
			private function loadSchemaChildren(schemaElementId:String, schema:Array):Array{
				var result:Array = new Array();
				for( var i:int = 0; i < schema.length; i++){
					if( schema[i].parent == schemaElementId)
						result[result.length]= schema[i];
					
				}
				return result;
			}
			
			/**
			 * Get a node of the schema by ID.
			 **/
			public function getSchemaNodeById(id:String):Object {
				return schemaIndex[id];
			}
			
			
			private function resetTreeAndEditor():void{
				this.tree.dataProvider = null;
			}
			private function _init():void{
				initializePageList();
				if( (dgList.dataProvider as ArrayCollection).length >0){
					dgList.selectedIndex = 0;
					doSwitchEntry();           			
				}
				this.initalizeStartLetterList();
				this.initializeLexicaList();
				this.initializePageNavigation();
				this.initializeQueryBuilder();
				this.initializeQueryList();
				dgList.validateNow();
				dgList.validateDisplayList();
				this.initializeEditor();
				FlexGlobals.topLevelApplication.moduleInitialised("lexicon_browser");

			}
			
			private function preprocessData(jsonData:Object):void {
				if (jsonData.result.myResult && jsonData.result.myResult.lexicalEntries) {
					var entries:ArrayCollection = new ArrayCollection(jsonData.result.myResult.lexicalEntries);
					for( var i:int = 0; i < entries.length; i++){
						var listView:Object = entries.getItemAt(i).listView;
						listView.value = this.transformListView(listView.value);
					}
				}
			}
			
			private function transformListView(listViewHTML:String):String{
				if( listViewHTML == null)
					return "";
				
				var txt:String = listViewHTML;
				
				/** AAM: Here, we need to do a replace the matching regular expressions as many times as needed. 
				 * e.g. the 1st replace can generate new '&amp;' regular expresions if we have: '&amp;amp'
				 * on the original 'txt' string.
				 * */
				
				var ampPattern:String = "\&amp;";
				var ltPattern:String = "\&lt;";
				var gtPattern:String = "\&gt;";
				var qtPattern:String = "\&quot;";
				
				while (txt.indexOf(ampPattern) != -1)
					txt  =txt.replace(ampPattern, "&");
				while (txt.indexOf(ltPattern) != -1)
					txt = txt.replace(ltPattern, "<");
				while (txt.indexOf(gtPattern) != -1)
					txt  =txt.replace(gtPattern, ">");
				while (txt.indexOf(qtPattern) != -1)
					txt  =txt.replace(qtPattern, "'");
		
				return txt;
			}
			
			private function initializeLexicaList():void{
				var lexicon:Object = serverData.result.myResult.lexicon;
				serverData.result.lexica.unshift({
					"id": "",
					"name": "<switch lexicon>"
				});
				var lexica:ArrayCollection = new ArrayCollection(serverData.result.lexica);
				for (var i:int = 0; i < lexica.length; i++) {
					var lx:Object = lexica.getItemAt(i);
					if (lx.name == serverData.result.myResult.lexicon.name)
						lx.name = lx.name + " (RELOAD)";
					lx.name = LexusUtil.cutOffString(lx.name, 40);
				}
			}
			private function initializeQueryList():void {
				queriesList = new ArrayCollection();
				var emptyQuery:Object = new Object();
				emptyQuery.name="<filter>";
				if (queryBuilder.queries != null) {
					for (var i:int = 0; i< queryBuilder.queries.length; i++)
						queriesList.addItem(queries[i]);
				}
				queriesList.addItemAt(emptyQuery, 0);
				this.querySelect.dataProvider = queriesList;
				this.querySelect.selectedIndex = 0;
				if (this.serverData.result.query != null) {
					var qId:String = this.serverData.result.query.id;
					
					for (var j:int = 0; j < queriesList.length; j++) {
						var query:Object = queriesList.getItemAt(j);
						if (query.id == qId) {
							this.querySelect.selectedIndex = j;
							break;
						}
					}					
				}
				
			}
			
			
			private function initalizeStartLetterList():void {
				var startLetter:String = serverData.result.myResult.startLetter;
				serverData.result.startLetters.splice(0, 0, {"label":"-","value":""});
				var startLetters:ArrayCollection = new ArrayCollection(serverData.result.startLetters);
				for(var i:int = 0; i < startLetters.length; i++) {
					var startLetterObj:Object = startLetters.getItemAt(i);
					
					
					
					if( startLetterObj.label == startLetter){
						startLetterList.selectedIndex = i;
						break;
					}
				}
			}
			
			/**
			 * Initializes the QueryBuilder to work with the current lexicon for this LexiconBrowser.
			 * This will cause the AddQueryElement to work on a single lexicon only. So queries constructed
			 * here always use the same (one) lexicon
			 **/ 
			private function initializeQueryBuilder():void{
				var lexicon:Object = this.serverData.result.myResult.lexicon;
				queryBuilder.lexicon = lexicon;
				queryBuilder.queries = queries;
			}
			private function initializePageNavigation():void{
				var startPage:int = this.serverData.result.myResult.startPage;
				if( startPage == 0){
					this.navPrevPage.enabled = false;
					this.navFirstPage.enabled = false;
				}
				else{
					this.navPrevPage.enabled = true;
					this.navFirstPage.enabled = true;
				}
				this.initializePageList();
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				if( startPage == (totalPages -1)){
					this.navNextPage.enabled = false;
					this.navLastPage.enabled = false;
				}
				else{
					this.navNextPage.enabled = true;
					this.navLastPage.enabled = true;
				}				
			}
			
			
			private function initializePageList():void {
				var startPage:int = this.serverData.result.myResult.startPage;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				var pageList:ArrayCollection = new ArrayCollection();
				var index:int = 0;
				for( var i:int = 0; i < totalPages; i++){
					var page:Object = new Object();
					page.label = "" + (i+1);
					page.value = i;
					pageList.addItem( page);
					if( page.value == startPage)
						index = i;
				}
				this.pageList.dataProvider = pageList;
				this.pageList.selectedIndex = index;
			}
			
			/**
			 * Handles the change event on the left tabs
			 * */
			private function leftTabChanged(evt:IndexChangedEvent):void{
				this.queryBuilder.requestSave();
				initializeQueryList();
				this.lexicalEntryView.enabled = true;
				this.lexicalEntryEditor.enabled = true;
				var tabNav:TabNavigator = evt.target as TabNavigator;
				if ((mx.containers.Canvas) (tabNav.selectedChild).id != "listView"){
					showSelectedEntry();
					rightTabNav.selectedChild = lexicalEntryEditor;
					iFrame.visible = false;
				}
				else if( tabNav.selectedChild == queryBuilder){
					this.lexicalEntryView.enabled = false;
					this.lexicalEntryEditor.enabled = false;
				}
			}
			
			/**
			 * Handles the change event in the list
			 **/
			private function switchEntry(evt: MouseEvent): void {
				doSwitchEntry(evt);
			}
			
			
			/**
			 * Performs all updates related to changes in the currently selected entry from the list
			 **/
			private function doSwitchEntry(event:MouseEvent = null):void {
				if (this.saveLexicalEntryTarget != null) {
					this.originalSwitchEvent = event;
					this.confirmLexicalEntrySave();
					return;
				}
				if (rightTabNav.selectedChild == lexicalEntryEditor) {
					showSelectedEntry();	
					iFrame.visible = false;
					dgList.setFocus();
				}
				else if (dgList.selectedItem!=null) {
					LexusUtil.showWait(this, "Loading lexical entry data");					
					var param:Object = new Object();
					param.id = dgList.selectedItem.id;
					param.lexicon = serverData.result.myResult.lexicon.id;
					this.lexusService.send("LexusLexicalEntryEditor/getLexicalEntryData.json", param, this.name, onLexicalEntryReload);
					dgList.setFocus();
				}		
			}
			
			
			/**
			 * Displays the information for the tooltip of the selected item in the left tree 
			 **/ 
			private function treeToolTip(item:Object):String{
				var report:Object = reportOnDataNode(item);
				var message:String = "";
				var i:int;
				if (report.errors.length > 0) {
					for (i = 0; i<report.errors.length ; i++) {
						message += report.errors[i] + "\n";
					}
				}
				else if (report.warnings.length > 0) {
					for (i = 0; i<report.warnings.length ; i++) {
						message += report.warnings[i] + "\n";
					}
				}
				else {
					message = item.value;
				}
				return message;
			}		
			
			
			/**
			 * Handles the click events in the left tree. Populates the list of acive schema elements 
			 * for the currently selected tree instance node
			 **/
			private function treeItemClicked(evt:ListEvent):void {					
				this.displayInstanceElement();	
			}
			
			/**
			 * Requests a confirmation from the user to save the changes.
			 * 
			 **/ 
			private function confirmLexicalEntrySave():void {
				YesNo.confirmSave("Do you want to save your changes?", confirmLexicalEntrySaveHandler);
			}
			
			/**
			 * Handles the user response to the save request presented to the user
			 **/ 
			private function confirmLexicalEntrySaveHandler(event:CloseEvent):void {
				if (event.detail == Alert.YES) {
					FlexGlobals.topLevelApplication.enabled  = false;
					LexusUtil.showWait(this, "Saving entry");					
					var param:Object = new Object();
					param.lexicalEntry  = this.saveLexicalEntryTarget;
					// param.schema = this.serverData.result.mySchema;
					param.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
					this.lexusService.send("LexusLexicalEntryEditor/saveLexicalEntry.json", param, this.name, onLexicalEntryReload);
				} 
				else {
					this.saveLexicalEntryTarget = null;
					process_original_event();
					// initializeEditor();
					/*
					LexusUtil.showWait(this, "Reloading entry");					
					var param1:Object = new Object();
					param1.id=this.saveLexicalEntryTarget.id;
					param.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
					this.lexusService.send("LexusLexicalEntryEditor/loadLexicalEntry.json", param1, this.name, onLexicalEntryReload);
					*/
				}
			}
			
			private function onLexicalEntryReload(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						if (data.status.success == false) {
							YesNo.alert(data.status.message);					
						}
						else if (data.status.success == true) {
							saveLexicalEntryTarget = null;
							data.result.lexicalEntry.listView.value = transformListView(data.result.lexicalEntry.listView.value);
							var coll:ICollectionView = (dgList.dataProvider as ICollectionView);
							var cursor:IViewCursor = coll.createCursor();
							var refresh:Boolean = (data.result.lexicalEntry.id == dgList.selectedItem.id);
							while (!cursor.afterLast){
								if (cursor.current.id == data.result.lexicalEntry.id){
									cursor.remove();
									cursor.insert( data.result.lexicalEntry);
									if (refresh){
										dgList.selectedItem = data.result.lexicalEntry;
										showSelectedEntry();
									}
									break;
								}
								cursor.moveNext();
							}
						}
						LexusUtil.removeWait();
						callLater(dgList.setFocus);
						process_original_event();
						FlexGlobals.topLevelApplication.enabled = true;
					}
				);
				lexicalEntryView.enabled = true;
				editor.enabled = true;
			}

			
			/**
			 * Process original event (if any).
			 */
			private function process_original_event():void {
				if (this.originalEvent != null) {
					FlexGlobals.topLevelApplication.menuBar.dispatchEvent(this.originalEvent);
					this.originalEvent = null;
				}
				
				if (this.originalSwitchEvent != null) {
					dgList.dispatchEvent(this.originalSwitchEvent);
					this.originalSwitchEvent = null;
				}
			}

			
			/**
			 * Get schema children of a node. If you already have the schemaElement you can supply it,
			 * otherwise, it will be looked up.
			 **/ 
			public function getSchemaChildren(node:Object, schemaElement:Object = null):Array {
				if (null == schemaElement) {
					schemaElement = getSchemaNodeById(node.schemaElementId);
				}
				var schemaChildren:Array = schemaElement.children;
				schemaChildren = this.filterMultipleAllowed(schemaChildren, node);
				return schemaChildren;
			}
			
			private function displayInstanceElement():void{	
				var idx:int = dgList.selectedIndex;
				var selectedNode:Object = tree.selectedItem;
				var schemaElement:Object = this.getSchemaNodeById(selectedNode.schemaElementId);
				if (schemaElement.type != "data category"){
					this.multimediaTab.enabled = false;
					this.displayDataCategory(schemaElement);
					this.displayNotes(selectedNode, false);
				}
				
				var schemaChildren:Array = getSchemaChildren(selectedNode, schemaElement);
				activeSchemaElements.dataProvider = schemaChildren.sortOn(["type", "name"], Array.CASEINSENSITIVE);
				if (schemaChildren.length > 0)
					schemaElementsPanel.enabled = true;
				else
					schemaElementsPanel.enabled = false;
				var widget:UIComponent = this.editorWidgets[tree.selectedItem.id]
				
				if( editor.verticalScrollBar!=null && editor.verticalScrollBar.visible){
					var p:Point = new Point( widget.x, widget.y);
					p = widget.localToGlobal( p);
					var p1:Point = editor.globalToLocal(p); 
					editor.verticalScrollPosition += p1.y;
				}
				
				callLater(widget.setFocus);
			}
			/**
			 *Filters out the schemaElements from the specified array for which only one instance is allowed and which
			 * is already present in the specified currentInstance
			 *
			 **/  
			private function filterMultipleAllowed( a_schemaElements:Array, a_currentInstance:Object):Array{
				var result:ArrayCollection = new ArrayCollection();
				for( var i:int = 0; i < a_schemaElements.length; i++){
					
					if( a_schemaElements[i].max == 1){
						//Check here whether it is already present in the currentInstance
						var children:ArrayCollection = new ArrayCollection( a_currentInstance.children);
						var found:Boolean = false;
						for( var j:int = 0; j < children.length; j++){
							var child:Object = children.getItemAt(j);
							if( child.schemaElementId == a_schemaElements[i].id){
								found = true;
								break;
							}
						}
						if( !found)
							result.addItem( a_schemaElements[i]);
					}
					else
						result.addItem( a_schemaElements[i]);
				}
				return result.toArray();
			}
			/**
			 * Handles the drag enter event for the tree
			 **/
			private function onTreeDragEnter(evt:DragEvent):void{
				var dropTarget:AutoSizeTree = AutoSizeTree(evt.currentTarget);
				var uiComp:IUIComponent = evt.dragInitiator;
				if( uiComp == activeSchemaElements && evt.dragSource.hasFormat( "items")){
					DragManager.showFeedback(DragManager.MOVE);
					DragManager.acceptDragDrop(dropTarget);
				}
				else {
					DragManager.showFeedback(DragManager.NONE);
					return;     	
				}
			}
			/**
			 * Handles the drag over event on the tree
			 **/
			private function onTreeDragOver( evt:DragEvent):void{
				evt.preventDefault();
				evt.currentTarget.showDropFeedback(evt);
				
				var dropTarget:AutoSizeTree = AutoSizeTree(evt.currentTarget);
				var r:int = dropTarget.calculateDropIndex(evt);
				tree.selectedIndex = r;
				var actSchemaElements:Array =evt.dragSource.dataForFormat("items") as Array;
				//if the activeSchemaElements from list does not match the id of the current item in tree return
				var dropEnabled:Boolean = true;
				for( var i:int = 0; i < actSchemaElements.length; i++){
					if( actSchemaElements[i].parent != tree.selectedItem.schemaElementId){
						dropEnabled = false;
						break;
					}
					
				}
				
				if( dropEnabled){
					DragManager.showFeedback(DragManager.MOVE);
					DragManager.acceptDragDrop(dropTarget);
				}
				else{
					DragManager.showFeedback(DragManager.NONE);
					return;
				}
				
			}
			/**
			 * Handles the drag drop event on the tree
			 **/
			private function onTreeDragDrop(evt: DragEvent):void{
				evt.preventDefault();
				evt.currentTarget.hideDropFeedback(evt);
				var dropTarget:AutoSizeTree =AutoSizeTree(evt.currentTarget);   
				var r:int = dropTarget.calculateDropIndex(evt);
				tree.selectedIndex = r;
				var actSchemaElements:Array =evt.dragSource.dataForFormat("items") as Array;
				for( var i:int = 0; i < actSchemaElements.length; i++){
					this.insertTreeNode(actSchemaElements[i]);
				}
				this.displayInstanceElement();
				this.markLexicalEntrySavePoint();
				
			}
			
			private function addSchemaElementToComponent(schemaElement:Object):void {
				if(activeSchemaElements.selectedItem != null){ 
					insertTreeNode(schemaElement);
					displayInstanceElement();
					markLexicalEntrySavePoint();
				}
				
			}
			private function generateTemporaryId():String{
				this.lastTmpId++;
				return "_tmp" + this.lastTmpId;
			}
			/**
			 * Inserts a new instance based on the specified schemaElement specification under the currently
			 * selected node in the tree
			 **/
			private function insertTreeNode(schemaElement:Object):void{
				var instanceElement:Object = new Object();
				instanceElement.id= this.generateTemporaryId();
				
				instanceElement.label=schemaElement.name;
				instanceElement.value = "";
				instanceElement.notes="";
				instanceElement.multimedia=null;
				instanceElement.schemaElementId=schemaElement.id;
				if( schemaElement.type != "data category")
					instanceElement.children=[];
				var children:ArrayCollection = new ArrayCollection(tree.selectedItem.children);
				children.addItemAt( instanceElement, 0);
				tree.invalidateDisplayList();
				tree.invalidateList();
				initializeEditor();
			}
			
			private function removeLIU(event:MouseEvent):void{
				var liu:Object = this.tree.selectedItem;
				var parent:Object = this.tree.getParentItem(liu);
				if (null != parent) {
					var children:ArrayCollection = new ArrayCollection( parent.children);
					children.removeItemAt( children.getItemIndex( liu));
					this.tree.invalidateDisplayList();
					this.tree.invalidateList();
					initializeEditor();
					this.saveLexicalEntryTarget = this.dgList.selectedItem;
				}
			}
			/**
			 * Returns the icon class for the specified schemaElement. This method is used by the List 
			 * of currently active schema elements to determine the icons associated with the schema elements
			 **/
			private function getElementIconClass( schemaElement:Object):Class{
				if( schemaElement.type =="data category")
					return FlexGlobals.topLevelApplication.dataCategoryIcon;
				else
					return FlexGlobals.topLevelApplication.containerIcon; 
				
				return null;
			}
			/**
			 * Shows the selected entry from the list
			 **/
			private function showSelectedEntry():void{
				if( dgList.selectedItem == null) 
					return;
				if( !dgList.selectedItem.hasOwnProperty("children")){
					editor.enabled = false;
					LexusUtil.showWait(this, "Loading lexical entry data");					
					var param:Object = new Object();
					param.id = dgList.selectedItem.id;
					param.lexicon = serverData.result.myResult.lexicon.id;
					this.lexusService.send("LexusLexicalEntryEditor/getLexicalEntryData.json", param, this.name, onLexicalEntryReload); 
					return;
				}	
				tree.dataProvider = dgList.selectedItem;
				if( rightTabNav.selectedChild == lexicalEntryEditor)
					initializeEditor();
				callLater(expandTree);
				tree.validateNow();
				tree.selectedIndex = 0;
				if( rightTabNav.selectedChild == lexicalEntryEditor)
					this.displayInstanceElement();
				else
					loadLEV(dgList.selectedItem.entryView);
			}
			
			private function expandTree():void{
				tree.expandChildrenOf( dgList.selectedItem, true);
			}
			
			/**
			 * Handles the event for changing lexica
			 **/
			private function changeLexica(evt:ListEvent):void {
				if (lexicaList.selectedItem.id != "") {
					iFrame.visible = false;
					FlexGlobals.topLevelApplication.enabled  = false;
					openLexicon(lexicaList.selectedItem.id);
				}
			}
			
			/**
			 * Handles the event for changing List vs Tree view
			 **/
			private function changeListTreeView(evt:MouseEvent):void {
				if (listAndTree.selectedChild == latList) {
					listAndTree.selectedChild = latTree;
					changeViewButton.label = "Switch to list view";
				}
				else {
					listAndTree.selectedChild = latList;
					changeViewButton.label = "Switch to structure view";
				}
			}
			
			/**
			 * Handles the navigate up button event
			 **/
			private function navigateUp( evt:Event):void{
				var index:int = dgList.selectedIndex;
				
				if( index < (dgList.dataProvider.length-1))
					index ++;
				dgList.selectedIndex=index;
				doSwitchEntry();
				dgList.scrollToIndex(index);
			}
			/**
			 * Handles the navigate down button event
			 **/
			private function navigateDown( evt:Event):void{
				var index:int = dgList.selectedIndex;
				if( index >0)
					index --;
				dgList.selectedIndex=index;
				doSwitchEntry();
				
				dgList.scrollToIndex(index);
			}
			/**
			 * Handles the event for navigating to the first page
			 **/
			private function navigateToFirstPage( evt:MouseEvent):void{
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				LexusUtil.showWait(this, "Loading entries");
				_startLetterSearch(0, LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			
			/**
			 * Handles the event for navigating to the last page
			 **/
			private function navigateToLastPage( evt:MouseEvent):void{
				FlexGlobals.topLevelApplication.enabled  = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				LexusUtil.showWait(this, "Loading entries");
				_startLetterSearch(totalPages-1, LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			/**
			 * Handles the event for navigating to the previous page
			 **/
			private function navigateToPreviousPage( evt:MouseEvent):void{
				var startPage:int = this.serverData.result.myResult.startPage;
				if( startPage >0){
					FlexGlobals.topLevelApplication.enabled  = false;
					iFrame.visible = false;
					var startLetter:String = this.serverData.result.myResult.startLetter;
					LexusUtil.showWait(this, "Loading entries");					
					_startLetterSearch(startPage-1, LEXICAL_ENTRIES_PER_PAGE);
					dgList.setFocus();
				}
			}
			/**
			 * Handles the event for navigating to the next page
			 **/
			private function navigateToNextPage( evt:MouseEvent):void{
				var startPage:int = this.serverData.result.myResult.startPage;
				var count:int = this.serverData.result.myResult.count;
				var total:int = this.serverData.result.myResult.total;
				var totalPages:int = Math.ceil( total/count);
				if( startPage < totalPages){
					FlexGlobals.topLevelApplication.enabled  = false;
					iFrame.visible = false;
					var startLetter:String = this.serverData.result.myResult.startLetter;
					LexusUtil.showWait(this, "Loading entries");					
					_startLetterSearch(startPage + 1, LEXICAL_ENTRIES_PER_PAGE);
					dgList.setFocus();
				}
			}
			/**
			 * Handles the event for navigating to another result page
			 **/
			private function changePage( evt: ListEvent):void{
				
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				var startLetter:String = this.serverData.result.myResult.startLetter;
				LexusUtil.showWait(this, "Loading entries");					
				_startLetterSearch(this.pageList.selectedItem.value, LEXICAL_ENTRIES_PER_PAGE);
				dgList.setFocus();
			}
			/**
			 * Handles the event for changing the tab on the top right side
			 **/
			private function rightTabChanged( evt:IndexChangedEvent):void{
				if( rightTabNav.selectedChild == lexicalEntryEditor){
					showSelectedEntry();	
					iFrame.visible = false;
				}
				else if( dgList.selectedItem != null){
					loadLEV(dgList.selectedItem.entryView);
					dgList.setFocus();
				} 
			}
			
			/**
			 * Handles the event for changing the tab on the bottom right side
			 **/			
			private function propertyTabChanged( evt:IndexChangedEvent):void{				
			}
			
			/**
			 * Handles the event for key down event for the list
			 **/
			private function keyHandler(event:KeyboardEvent):void
			{
				switch( event.keyCode){
					case 38: doSwitchEntry();
						break;
					case 40: doSwitchEntry();
						break;
				}
			}
			
			
			private function initializeEditor():void{
				lexicalEntryData = ObjectUtil.copy(dgList.selectedItem);
				editor.removeAllChildren();
				editorWidgets = new Array();
				instanceDataElements = new Array();
				var editable:Boolean = serverData.result.myResult.lexicon.writable;
				removeLexicalEntryButton.visible = editable;
				queryBuilder.editable(editable);
				newLexicalEntryButton.visible = editable;
				schemaElementsPanel.visible = editable;
				removeElementButton.visible = editable;
				_initializeEditor(lexicalEntryData, editor, editable, initialColorLevel);
				
			}
			
			private function getColor( r:int, g:int, b:int):String{
				return "0x" + fixedInt(rgbToInt(r, g, b), '000000'); 
			}
			private function fixedInt(value:int, mask:String):String {
				return String(mask + value.toString(16)).substr(-mask.length).toUpperCase();
			}
			
			private function rgbToInt(r:int, g:int, b:int):int {
				return r << 16 | g << 8 | b << 0;
			}
			
			private function _initializeEditor(object:Object, parentContainer:Container, isEditable:Boolean, colorLevel:int):void {
				if (object == null)
					return;
				this.instanceDataElements[object.id] = object;
				
				if( object.hasOwnProperty("children")){
					var parentCont:Container = null;
					if( parentContainer is GridRow){
						parentCont = new GridItem();
						parentCont.percentWidth = 100;
						(parentCont as GridItem).colSpan = 2;
						parentContainer.addChild( parentCont);
					}
					else
						parentCont = parentContainer;
					var panel:Panel = new Panel();
					this.editorWidgets[object.id]=panel;
					panel.title = object.label;
					panel.percentWidth=100;
					panel.percentHeight=100;
					panel.setStyle("paddingTop", 10);
					panel.setStyle( "paddingLeft", 20);
					panel.setStyle( "paddingBottom", 5);
					
					var colorStr:String = this.getColor( colorLevel, colorLevel, colorLevel);
					panel.setStyle("backgroundColor", colorStr);
					
					var grid:Grid = new Grid();
					grid.percentWidth = 100;
					grid.percentHeight = 100;            		
					panel.addChild(grid);
					for( var i:int = 0; i < object.children.length; i++){
						var row:GridRow = new GridRow();
						row.percentHeight=100;
						row.percentWidth=100;
						colorLevel =((colorLevel+8>255)? this.initialColorLevel:colorLevel +8);
						_initializeEditor( object.children[i], row, isEditable, colorLevel);
						grid.addChild( row);
					}	
					parentCont.addChildAt(panel, 0);
				}
				else{
					var gridItem1:GridItem = new GridItem();
					gridItem1.percentWidth=100;
					var label:Label = new Label();
					label.text = object.label;
					gridItem1.addChild( label);
					gridItem1.percentWidth = 30;
					
					/**
					 *AAM: Icon handeling. 
					 * Displays an icon at the end of the datacategory name, indicating the multimedia type
					 * atached to that datacategory (if there is multimedia atached). 
					 **/ 
					
					if (object.multimedia != null){
						var icon:Image = new Image();
						
						switch (object.multimedia.type) {
							case "image":
								icon.source = cameraIcon;
								break;
							case "video":
								icon.source = filmIcon;
								break;
							case "audio":
								icon.source = soundIcon;
								break;
							case "externalURL":
								icon.source = externalLinkIcon;		
								break;
							case "url":
								icon.source = internalLinkIcon;
								break;
							default:
								trace("Cannot find multimedia icon. Unknown data type!");
								break;
						}

					icon.alpha =0.9;
					icon.width = 16;
					gridItem1.addChild( icon);
					}
					
					
					var gridItem2:GridItem = new GridItem();
					gridItem2.percentWidth = 70;
					if( object.valuedomain == null){
						//var edit:TextArea = new TextArea();
						var edit:CustomTextArea2 = new CustomTextArea2();
						edit.percentWidth = 100;
						edit.percentHeight = 100;
						edit.id = object.id;
						this.editorWidgets[object.id]=edit;
						
						edit.text = object.value;
						edit.editable = isEditable;
						var emptyValueIndicator:Function =  
							function():void { // Change background color to orange as a warning.
								if (edit.text == "") {
									edit.setStyle("backgroundColor", "#FFAA00");
								}
								else {
									edit.setStyle("backgroundColor", "#FFFFFF");            			  		
								}
							};
						emptyValueIndicator();
						edit.addEventListener(FocusEvent.FOCUS_IN , displayProperties);
						edit.addEventListener(Event.CHANGE, onContentChange);
						edit.addEventListener(Event.CHANGE, emptyValueIndicator);
						gridItem2.addChild( edit);
					}
					else{
						var cBox:ComboBox = new ComboBox;
						var list:ArrayCollection = new ArrayCollection();
						for( var j:int = 0; j < object.valuedomain.length; j++){
							var item:Object = new Object();
							item.label = object.valuedomain[j];
							item.data = null;
							list.addItem( item);
						}
						cBox.dataProvider = list;
						cBox.id = object.id;
						cBox.editable = isEditable;
						this.editorWidgets[object.id]=cBox;
						cBox.addEventListener(FocusEvent.FOCUS_IN , displayProperties);
						cBox.addEventListener(ListEvent.CHANGE, onContentChange);
						
						gridItem2.addChild( cBox); 
					}
					parentContainer.addChild( gridItem1);
					parentContainer.addChild( gridItem2);
				}
			}
			
			private function onContentChange( event:Event):void{
				this.markLexicalEntrySavePoint();
				var widget:UIComponent = (event.target as UIComponent);
				
				if( widget is TextArea){
					var selObj:Object = this.instanceDataElements[ widget.id];
					selObj.value = (widget as TextArea).text;
				}
				else if( widget is ComboBox){
					var selObj1:Object = this.instanceDataElements[ widget.id];
					selObj1.value = (widget as ComboBox).selectedItem;
				}
			}
			
			private function markLexicalEntrySavePoint():void{
				this.saveLexicalEntryTarget = this.lexicalEntryData;
			}
			private function displayProperties(evt:FocusEvent):void{
				
				var uiComp:UIComponent = evt.currentTarget as UIComponent;
				this.currentSelectedWidget = uiComp;
				var dataElement:Object = this.loadDataElement( uiComp.id);
				var media:UIComponent = null;
				this.displayMultiMedia( dataElement.multimedia, dataElement.value, this.serverData.result.myResult.lexicon.writable);
				var schemaElement:Object = this.getSchemaNodeById( dataElement.schemaElementId);
				this.displayDataCategory( schemaElement);
				this.displayNotes( dataElement, this.serverData.result.myResult.lexicon.writable);
			}
			
			private function displayDataCategory( data:Object):void{
				this.dataCategoryTab.label = "Properties";
				dc_name.text = data.name;
				dc_description.text = data.description;
				dc_adminInfo.text = data.adminInfo;
				var mandatory:Boolean = (data.min=="0"?false:true);
				dc_mandatory.selected = mandatory;
				var multiples:Boolean = (data.max=="1"?false:true);
				dc_multiples.selected = multiples;
				var valDom:ArrayCollection = new ArrayCollection( data.valuedomain);
				
				/* HHV: temporarily removed as requested by Menzo, since it's not really supported yet.
				if( valDom.length > 0){
					var text:String = "";
					for( var i:int = 0; i < valDom.length; i++){
						text += valDom.getItemAt( i);
						if( i != valDom.length -1)
							text += ", ";
					}
					dc_valuedomain.text = text;
				}
				else
					dc_valuedomain.text = "<Any>"
				*/
			}
			private function displayMultiMedia(multiMedia:Object, label:String, editable:Boolean):void{
				multimediaTab.enabled = true;
				mediaPanel.visible = false;
				this.importMM_button1.enabled = editable;
				this.importMM_button2.enabled = editable;
				this.importMM_button3.enabled = editable;
				this.importMM_button4.enabled = editable;
				this.importMM_button5.enabled = editable;
				imagePanel.visible = false;
				videoPanel.visible = false;
				audioPanel.visible = false;
				uploadPanel.visible = false;
				importPanel.visible = false;
				urlPanel.visible = false;
				if( currentSoundChannel != null)
					currentSoundChannel.stop();
				currentSound = null;
				currentSoundChannel = null;
				currentSoundPosition = 0;
				
				if( multiMedia == null){
					importPanel.visible = true;
					return;
				}
				//We will hit this point when the mediaWindow is closed and the properties are redisplayed. We don't want to open it again automatically at this point
				var openNewWindow:Boolean = true;
				if( this.mediaWindow != null){
					
					if( multiMedia.url =="" || multiMedia.url != this.mediaWindow.currentSource){
						this.mediaWindow.closeWindow();
						
					}
					else
						openNewWindow = false;
					//return;
				}
				
				switch (multiMedia.type) {
					case "image":
						image.source = multiMedia.url;
						imagePanel.visible = true;
						break;
					case "video":
						if( openNewWindow){
							openAudioVideoWindow( multiMedia, label);
						}
						mediaPanel.visible = true;
						videoPanel.visible = true;
						break;
					case "audio":
						if( openNewWindow)
							openAudioVideoWindow( multiMedia, label);						
						mediaPanel.visible = true;
						videoPanel.visible = true;
						break;
					case "upload":
						uploadPanel.visible = true;
						break;
					case "url":
						urlPanel.visible = true;
					case "externalURL":
						urlPanel.visible = true;
						break;
					default:
						importPanel.visible = true;
						break;
				}
			}
			
			private function openAudioVideoWindow( multiMedia:Object, label:String):void{
				var globalPt:Point = new Point( 500, 400);
				var localPt:Point = this.globalToLocal( globalPt);
				
				this.mediaWindow = MediaWindow( PopUpManager.createPopUp( this, MediaWindow, true));
				this.mediaWindow.title = label;
				this.mediaWindow.x = localPt.x;
				this.mediaWindow.y = localPt.y;
				this.mediaWindow.currentSource = multiMedia.url;
			}
			
			
			private var currentSound:Sound = null;
			private var currentSoundChannel:SoundChannel = null;
			private var currentSoundPosition:int =0;
			private function playSound():void{
				if( currentSound != null){
					currentSoundChannel = currentSound.play(currentSoundPosition);
				}
			} 
			private function pauseSound():void{
				if( currentSoundChannel != null){
					currentSoundPosition = currentSoundChannel.position;
					trace( "currentSoundPosition=" + currentSoundPosition);
					currentSoundChannel.stop();
				}
				
			}
			
			private function stopSound():void{
				currentSoundPosition = 0;
				if( currentSoundChannel!=null)
					currentSoundChannel.stop();	
			}
			
			private function videoStateChange( evt:VideoEvent):void{
				trace("statechange");
			}
			
			private function displayNotes(data:Object, editable:Boolean):void{
				this.notes.enabled = editable;
				notes.text = data.notes;
			}
			
			private function loadDataElement( id:String):Object{
				return _loadDataElement( id, dgList.selectedItem);
			}
			private function _loadDataElement( id:String, data:Object):Object{
				if( data.id == id)
					return data;
				
				var result:Object = null;
				if( data.hasOwnProperty("children")){
					for( var i:int = 0; i < data.children.length; i++){
						result = _loadDataElement( id, data.children[i]);
						if( result != null)
							break;
					}
				}
				return result;
			}
			
			
			/**
			 * Event handler for the Menu control's click event.
			 **/
			public function onMenuSelect(event:MenuEvent):Boolean  {
				var handled:Boolean = true;
				var url:String;
				var popExport:FileDownloadBox;
				this.originalEvent = null;
				var evtName:String = event.item.@eventName;
				
				if (evtName == "save") {
					save();
					return true;
				}
				
				/** Request Save actions for other menu items, if necessary.
				 *  If something needs saving, store the original event so that it can
				 *  be dispatched again after the save.
				 **/
				if (saveNeeded()) {
					this.originalEvent = event;
					trace("this.originalEvent="+this.originalEvent);
					//event.preventDefault();
					requestSave();
					return true;
				}

				
				switch (evtName) {
					case "import_shbx":
						var popShbxImport:ShbxImport = ShbxImport(PopUpManager.createPopUp(this,ShbxImport,true));
						popShbxImport.importLexiconId = serverData.result.myResult.lexicon.id;
						popShbxImport.existingLexicon = true;
						popShbxImport.sessionId = sessionId;
						popShbxImport.addEventListener("new", handleLexiconImport);
						PopUpManager.centerPopUp(popShbxImport);
						popShbxImport.y = 20;
						break;
					case "schema_editor":
						iFrame.visible = false;
						FlexGlobals.topLevelApplication.lexiconId = serverData.result.myResult.lexicon.id; 
						handled = false;
						break;
					case "workspace": case "about":
						iFrame.visible = false;
						handled = false;
						break;
					case "export_xml":
						url = lexusService.getAbsoluteURL("XMLexport.zip?id="+serverData.result.myResult.lexicon.id);
						popExport = FileDownloadBox(PopUpManager.createPopUp(this, FileDownloadBox, false));
						popExport.theUrl = url;
						popExport.filename = serverData.result.myResult.lexicon.name + ".zip";
						PopUpManager.centerPopUp(popExport);
						popExport.start();
						break; 
					case "export_pdf":
						var ppp:PDFParameters = PDFParameters(PopUpManager.createPopUp(this, PDFParameters, false));
						ppp.theUrl = lexusService.getAbsoluteURL("LexusLexicalEntryEditor/PDFexport.pdf");
						ppp.lexiconId = serverData.result.myResult.lexicon.id;
						ppp.filename = serverData.result.myResult.lexicon.id.slice(5) + ".pdf";
						PopUpManager.centerPopUp(ppp);
						ppp.start();
						break;                	
					case "export_midi":
						url = lexusService.getAbsoluteURL("Archive/getImdiArchiveObject.json?id="+serverData.result.myResult.lexicon.id);
						popExport = FileDownloadBox(PopUpManager.createPopUp(this, FileDownloadBox, false));
						popExport.theUrl = url;
						PopUpManager.centerPopUp(popExport);
						popExport.start();
						break;
					default:
						handled = false;
						break;
				}
				return handled;
			}
			
			
			/* Save unsaved data, called from menu event handler or keyboard handler */
			public function save():void {           	
				if( this.saveLexicalEntryTarget != null){
					FlexGlobals.topLevelApplication.enabled  = false;
					LexusUtil.showWait(this, "Saving entry");					
					var param:Object = new Object();
					param.lexicalEntry  = this.saveLexicalEntryTarget;
					// param.schema = this.serverData.result.mySchema;
					param.lexicon = FlexGlobals.topLevelApplication.lexiconId;	
					this.lexusService.send("LexusLexicalEntryEditor/saveLexicalEntry.json", param, this.name, onLexicalEntryReload);
				}
				if (queryBuilder.saveNeeded()) {
					queryBuilder.save();
				}
			}

			//Save necessary?
			private function saveNeeded():Boolean {
				if (this.saveLexicalEntryTarget != null) {
					return true;
				}
				if (this.queryBuilder.saveNeeded()) {
					return true;	
				}            	
				return false;
			}    

			//Request Save actions for other menu items, if necessary.
			private function requestSave():Boolean {
				if (saveNeeded()) {
					this.confirmLexicalEntrySave();
					return true;
				}
				if (this.queryBuilder.saveNeeded()) {
					this.queryBuilder.requestSave();
					return true;	
				}            	
				return false;
			}
			
			private function handleLexiconImport(event:NewLexiconEvent):void {
			}
			
			private function zoomImage( evt:MouseEvent):void{
				
				if( this.currentSelectedWidget != null){
					var dataElement:Object = this.loadDataElement( this.currentSelectedWidget.id);
					if( dataElement.multimedia != null){
						switch(dataElement.multimedia.type){
							case "image":
								var popImage:ImageZoom = ImageZoom(PopUpManager.createPopUp(this,ImageZoom,true));
								var glbPt:Point = new Point( 100, 100);
								var lclPt:Point = this.globalToLocal( glbPt);
								popImage.x = lclPt.x;
								popImage.y = lclPt.y;
								popImage.title = dataElement.value;
								popImage.source = dataElement.multimedia.url;
								PopUpManager.centerPopUp(popImage);
								break;
							case "video": 
								this.openAudioVideoWindow(dataElement.multimedia, dataElement.value);
								break;
							case "audio":
								this.openAudioVideoWindow(dataElement.multimedia, dataElement.value);
								break;
							case "url":
								ExternalInterface.call( "window.open", dataElement.multimedia.url);
								break;
							case "externalURL":
								ExternalInterface.call( "window.open", dataElement.multimedia.url);
								break;
						}
					}
				}
			} 
			
			private function getListView( item:Object, column:DataGridColumn):String{
				return item.listView.value;
			}
			
			private function importResource():void{
				var popImport:ImportResourceWindow = ImportResourceWindow(PopUpManager.createPopUp(this,ImportResourceWindow,true));
				popImport.sessionId = this.serverData.result.sessionID;
				popImport.source = this.currentSelectedWidget.id;
				popImport.addEventListener( "complete", this.importResourceComplete);
				PopUpManager.centerPopUp(popImport);
				return;		
			}
			
			
			private function importResourceComplete( event:ImportCompleteEvent):void{
				
				var multiMedia:Object = new Object();
				multiMedia.type="upload";
				multiMedia.archive = event.archive;
				multiMedia.value = event.resourceId;
				multiMedia.fragmentIdentifier = event.fragmentIdentifier;
				multiMedia.url = event.url;
				this.instanceDataElements[event.source].multimedia = multiMedia;
				this.displayMultiMedia( this.instanceDataElements[event.source].multimedia, this.instanceDataElements[event.source].value, this.serverData.result.myResult.lexicon.writable);
				this.markLexicalEntrySavePoint();
			}
			/**
			 * Event handler for the cancel event on the resource browse window.
			 **/ 
			private function resourceCancelHandler( event:Event):void{
				FlexGlobals.topLevelApplication.enabled  = true;
			}
			/**
			 * Event handler for when a user has selected a resource to upload
			 **/
			private function resourceSelectHandler(event:Event):void {
				var fileRef:FileReference = FileReference(event.target);
				var cookie:String = this.serverData.result.sessionID;
				var uploadURLdata:URLRequest = new URLRequest("StagingFileHandler/uploadFile.json;jsessionid=" + cookie);
				var variables:URLVariables = new URLVariables();
				variables.requestId = this.currentSelectedWidget.id;
				uploadURLdata.data = variables;
				
				fileRef.addEventListener(Event.COMPLETE, completeHandler);
				fileRef.addEventListener(DataEvent.UPLOAD_COMPLETE_DATA,resourceUploadCompleteDataHandler);
				fileRef.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);
				fileRef.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
				fileRef.addEventListener(ProgressEvent.PROGRESS, progressHandler);
				fileRef.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				
				fileRef.upload(uploadURLdata, "resource");
			}
			private function resourceUploadCompleteDataHandler(event:DataEvent):void {
				trace("resource uploadCompleteData: " + event);
				FlexGlobals.topLevelApplication.enabled  = true;
				var rawData:String = String(event.data);
				var result:Object = (JSON.decode(rawData) as Object).result;
				var resourceFileStagingID:String = result.resource; //data is the field specified in the dataFileREf.upload request
				if( this.instanceDataElements[result.requestId].multimedia == null)
					this.instanceDataElements[result.requestId].multimedia = new Object();
				this.instanceDataElements[result.requestId].multimedia.value=resourceFileStagingID;
				this.instanceDataElements[result.requestId].multimedia.type="upload";
				// this.instanceDataElements[result.requestId].multimedia.mimetype=result.mimetype;
				if( this.tree.selectedItem == this.instanceDataElements[result.requestId])
					this.displayMultiMedia( this.tree.selectedItem.multimedia, this.tree.selectedItem.value, this.serverData.result.myResult.lexicon.writable);
				
				this.markLexicalEntrySavePoint();
			}
			private function completeHandler(event:Event):void {
				trace("completeHandler: " + event);
			}
			private function httpStatusHandler(event:HTTPStatusEvent):void {
				trace("httpStatusHandler: " + event);
			}
			
			private function ioErrorHandler(event:IOErrorEvent):void {
				trace("ioErrorHandler: " + event);
			}
			private function progressHandler(event:ProgressEvent):void {
				var file:FileReference = FileReference(event.target);
				trace("progressHandler name=" + file.name + " bytesLoaded=" + event.bytesLoaded + " bytesTotal=" + event.bytesTotal);
			}
			
			private function securityErrorHandler(event:SecurityErrorEvent):void {
				trace("securityErrorHandler: " + event);
			}
			
			private function convert( str:String):String{
				var myPattern:RegExp = /\//g;
				return str.replace(myPattern, "/");
			}
			private function updateNote():void{
				this.markLexicalEntrySavePoint();
				this.instanceDataElements[this.currentSelectedWidget.id].notes = this.notes.text;
			}
			private function removeLexicalEntry(event:MouseEvent):void{
				YesNo.confirmDelete("Are you sure you want to remove this entry?", confirmDeleteEntryHandler);
			}
			private function confirmDeleteEntryHandler( event:CloseEvent):void{
				if (event.detail == Alert.YES) {
					LexusUtil.showWait(this, "Deleting lexical entry");
					var param:Object = new Object();
					param.lexicon = serverData.result.myResult.lexicon.id;
					param.lexicalEntry = dgList.selectedItem;
					this.lexusService.send("LexusLexicalEntryEditor/deleteLexicalEntry.json", param, this.name, onDeleteEntryResult);	
				} 
				
			}
			private function onDeleteEntryResult(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						LexusUtil.removeWait();
						// Clear the copy used for editing, ticket #835.
						lexicalEntryData = null;
						var id:String = data.result.id;
						var entries:ArrayCollection = dgList.dataProvider as ArrayCollection;
						var i:int;
						for (i = 0; i < entries.length; i++){
							var entry:Object = entries.getItemAt(i);
							if (entry.id == id) {
								entries.removeItemAt(i);
								// dgList.invalidateDisplayList();
								dgList.invalidateList();
								if (saveLexicalEntryTarget == entry)
									saveLexicalEntryTarget = null;
								break;
							}
						}
						callLater(
							function():void {
								if (entries.length > 0) {
									dgList.selectedIndex = i > entries.length ? entries.length : i;
								}
								initializeEditor();
							}
						);
					}
				);
			}
			
			private function createLexicalEntry():void{
				var parameter:Object = new Object();
				parameter.id=serverData.result.myResult.lexicon.id;
				parameter.lexicon=serverData.result.myResult.lexicon.id;
				lexusService.send("LexusLexicalEntryEditor/createLexicalEntry.json", parameter, this.name, onJSONLoadNewLexicalEntry);
			}
			
			private function onJSONLoadNewLexicalEntry(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {
						var entry:Object = data.result.lexicalEntry;
						entry.listView.value = transformListView(entry.listView.value);
						(dgList.dataProvider as ArrayCollection).addItem(entry);
						dgList.selectedItem = entry;
						doSwitchEntry();
					}
				);
			}
			
			
			/**
			 * Get a report with errors and warnings on a datanode.
			 * Returns {"errors", ["error message", ...], "warnings", ["warning message",...]} otherwise.
			 * The message arrays can be empty of course. 
			 **/
			public function reportOnDataNode(data:Object):Object {
				var report:Array = [];
				var schemaNode:Object = getSchemaNodeById(data.schemaElementId);
				if (schemaNode != null) {
					var children:Array = schemaNode.children;
					
					report = report.concat(checkCardinality(data, schemaNode, children));
					report = report.concat(checkEmptyValue(data));
				}
				
				/**
				 * Convert the array of messages to a convenient object
				 * with errors apart from warnings.
				 **/
				var reportObject:Object = new Object();
				reportObject.warnings = [];
				reportObject.errors = [];
				for each (var item:Object in report) { 
					if (item.warning)
						reportObject.warnings.push(item.warning);
					if (item.error)
						reportObject.errors.push(item.error);
				} 
				return reportObject;
			}
			
			/**
			 * Returns [] if the value of data element is not "".
			 * Returns [{"warning": "message"}, ...] otherwise.
			 **/
			private function checkEmptyValue(data:Object):Array {
				var report:Array = [];
				
				if (null != data.value && data.value == "")
					report.push({"warning": "The field is empty."});
				return report;
			}
			
			/**
			 * Returns [] if the data element conforms to cardinality in the schema.
			 * Returns [{"error": "errormessage"}, ...] otherwise.
			 **/
			private function checkCardinality(data:Object, schemaNode:Object, children:Array):Array {
				var report:Array = [];
				
				for (var i:int = 0; i < children.length; i++) {
					var child:Object = children[i];
					if (child.min != null) {
						if (countDataNodesWithSchemaId(data.children, child.id) < child.min)
							report.push({"error":
								"There should be a minimum of " + child["min"] + " " + child["name"] + " (" + child["description"] + ") nodes."}); 
					}
					if (child["max"] != null) {
						if(countDataNodesWithSchemaId(data["children"], child["id"]) > child["max"] )
							report.push({"error":
								"A maximum of " + child["min"] + " " + child["name"] + " (" + child["description"] + ") nodes is allowed."});
					}
				}
				return report;
			}
			
			/**
			 * Return the number of data nodes that have the correct schema ID
			 **/			
			private function countDataNodesWithSchemaId(children:Array, schemaId:String):int {
				var count:int = 0;	
				for (var i:int = 0; i < children.length ; i++) {
					if(children[i]["schemaElementId"] == schemaId) {
						count++;
					}
				}
				return count;
			}
			
			private function loadLEV(url:String):void {
				iFrame.source=url;
				iFrame.visible=true;
			}
			
			//Font BugFix
			private var osName:String;
			private var textFont:String;
			
			private function setDefaultFont():void{
				osName = flash.system.Capabilities.os;
				switch(true){
					case (osName.indexOf("Windows") != -1):
						textFont = "Arial Unicode MS";
						break;
					case (osName.indexOf("Mac") != -1):
						textFont = "Lucida Grande";
						break;
					case (osName.indexOf("Linux") != -1):
						textFont = "DejaVu Sans";
						break;
				}
				
					
				
			}				
			
			private function initApp():void{
				// retrieve list of fonts available on user's computer and populate 'Tier text font' combobox
				var allFonts:Array = Font.enumerateFonts(true);
				allFonts.sortOn("fontName", Array.CASEINSENSITIVE);
				
				var fontIndex:int = -1;
				var fontFound:Boolean = false;
				for (var i:uint = 0; i < allFonts.length; i++){
					if (allFonts[i].fontName == textFont){
						fontIndex = i;
						fontFound = true;
						break;
					}
				}
				
				if (!fontFound){	
					textFont = "_sans";		
					fontChooser.prompt = "Select a font";
				}
				
				fontChooser.labelField = "fontName";
				fontChooser.dataProvider = allFonts;
				fontChooser.selectedIndex = fontIndex;
				var fontSize:String = this.styleManager.getStyleDeclaration(".customtext").getStyle("fontSize");
				var fontSizes:ArrayCollection = (this.fontSizeChooser.dataProvider as ArrayCollection);
				for( var j:int = 0; j < fontSizes.length;j++){
					if( fontSizes.getItemAt(j) == fontSize){
						this.fontSizeChooser.selectedIndex = j;
						break;
					}
				} 
				
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontFamily", textFont);
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontSize", fontSize);
			}
			
			private function textFontChanged(evt:ListEvent):void{
				
				textFont = this.fontChooser.selectedItem.fontName;
				var fontSize:Object = this.fontSizeChooser.selectedItem;
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontFamily", textFont);
				this.styleManager.getStyleDeclaration(".customtext").setStyle("fontSize", fontSize);

			}
			
			
			/*
				Send a query to the server.
			*/
			private function sendQuery(evt:Event):void{
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				
				LexusUtil.showWait(this, "Loading entries");
				this._startLetterSearch(0, LEXICAL_ENTRIES_PER_PAGE);
			}
			
			/*
				Reset query parameters and send query to the server.
			*/
			private function resetQuery(evt:Event):void{
				FlexGlobals.topLevelApplication.enabled  = false;
				iFrame.visible = false;
				
				searchTerm.text = "";
				caseSensitiveCheckbox.selected = false;
				querySelect.selectedIndex = 0;
				startLetterList.selectedIndex = 0;
				this._startLetterSearch(0, LEXICAL_ENTRIES_PER_PAGE);
			}
			
		]]>
	</mx:Script>
	
	<mx:Resize id="showSchemaElementsPanel" heightBy="200"/>
	<mx:Resize id="hideSchemaElementsPanel" heightBy="-200"/>
	
	<mx:HTTPService id="service" resultFormat="text" url="../assets/getPageAndDoQuery.json"
					result="onJSONLoad(event)"/>
	<mx:VBox id="main" width="100%" height="100%" verticalGap="0" 
			 focusIn="FlexGlobals.topLevelApplication.overlayUnicodeInput(event)">
		<mx:Panel width="100%" height="100%" status="Lexicon editor"
				  statusStyleName="panelStatus"
				  title="{LexusUtil.cutOffString(serverData.result.myResult.lexicon.name + ': ' + serverData.result.myResult.lexicon.description, maxTitleLength)}"
				  titleStyleName="panelTitle" backgroundAlpha="0.0" borderAlpha="0.0">
			<mx:Canvas id="canvasBrw" cachePolicy="off" width="100%" height="100%">
				<mx:TabNavigator width="100%" height="100%" creationPolicy="all"
								 change="leftTabChanged(event)">
					<mx:Canvas id="listView" label="Lexicon" width="100%" height="100%"
							   backgroundAlpha="0.0">
						<mx:HBox width="100%" height="100%" backgroundAlpha="0.0">
							<mx:VBox id="entryBrowser" height="100%" width="25%" backgroundAlpha="0.0" paddingLeft="6" paddingBottom="4">
								<mx:HBox id="controlPanel" width="100%" height="10%"
										 backgroundAlpha="0.0">
									<mx:VBox backgroundColor="#6ec6fd" height="100%" width="60%" horizontalAlign="left" cornerRadius="4" borderStyle="solid" paddingLeft="2" paddingBottom="2" paddingTop="2" paddingRight="2">
										<mx:ComboBox id="lexicaList"
													 dataProvider="{serverData.result.lexica}" labelField="name"
													 change="changeLexica(event)" kerning="true" maxWidth="200"/>
										<mx:Button label="Switch to structure view"  width="180" id="changeViewButton" click="changeListTreeView(event)" color="white"/>
									</mx:VBox>
									<mx:VBox backgroundColor="#6ec6fd" height="100%" width="60%" horizontalAlign="left" cornerRadius="4" borderStyle="solid" paddingLeft="2" paddingBottom="2" paddingTop="2" paddingRight="2">
										<mx:HBox width="100%" verticalAlign="bottom">
											<mx:ComboBox id="startLetterList"
													 dataProvider="{serverData.result.startLetters}"/>
											<mx:TextInput id="searchTerm" text="{serverData.result.myResult.searchTerm}" enter="sendQuery(event)"/>
											<mx:CheckBox id="caseSensitiveCheckbox" selected="{serverData.result.myResult.hasOwnProperty('caseSensitive') ? serverData.result.myResult.caseSensitive : false}" label="aBc"/>
										</mx:HBox>
										<mx:HBox width="100%">
											<mx:ComboBox id="querySelect"
														 maxWidth="150"
														 dataProvider="{queriesList}"
														 labelField="name"/>
											<mx:Spacer width="100%"/>
											<mx:Button id="resetQueryButton" label="All" click="resetQuery(event)"/>
											<mx:Button id="sendQueryButton" label="Ok" click="sendQuery(event)"/>
										</mx:HBox>
									</mx:VBox>
								</mx:HBox>
								<mx:ViewStack id="listAndTree" width="100%" height="90%">
									<mx:Panel id="latList" title="Lexical entries" width="100%" height="100%">
										<mx:DataGrid variableRowHeight="true" id="dgList" width="100%" height="100%" includeInLayout="true"
													 dataProvider="{serverData.result.myResult.lexicalEntries}"
													 click="switchEntry(event)" keyDown="keyHandler(event)" keyUp="keyHandler(event)" dragMoveEnabled="false" sortableColumns="false">
											<mx:columns>
												<mx:DataGridColumn headerText="">
													<mx:itemRenderer>
														<mx:Component>
															<mx:Text maxWidth="300" cachePolicy="off" condenseWhite="true" htmlText="{data.listView.value}"/>															
														</mx:Component>
													</mx:itemRenderer>
												</mx:DataGridColumn>
												<!--
												<mx:DataGridColumn width="20">
													<mx:itemRenderer>
														<mx:Component>
													<mx:Image source="images/film.png"/>
														</mx:Component>
													</mx:itemRenderer>
												</mx:DataGridColumn>
												-->
											</mx:columns>
										</mx:DataGrid>
										
										<mx:ControlBar width="100%" horizontalAlign="left">
											<mx:HBox width="10%" horizontalAlign="left">
												<mx:Image id="newLexicalEntryButton"
														  source="{application.addIcon}"
														  click="createLexicalEntry()" toolTip="Add lexical entry"/>
												<mx:Image id="removeLexicalEntryButton"
														  source="{application.removeIcon}"
														  click="removeLexicalEntry(event)"
														  toolTip="Remove lexical entry"/>
											</mx:HBox>
											<mx:HBox width="90%" horizontalAlign="right">
												<mx:Image id="navFirstPage"
														  source="{application.firstIcon}"
														  click="navigateToFirstPage(event)"
														  toolTip="Go to first page"/>
												<mx:Image id="navPrevPage"
														  source="{application.leftIcon}"
														  click="navigateToPreviousPage(event)"
														  toolTip="Go to previous page"/>
												<!-- <mx:Label text="Page"/> -->
												<mx:ComboBox id="pageList" labelField="label"
															 change="changePage( event)"/>
												<mx:Image id="navNextPage"
														  source="{application.rightIcon}"
														  click="navigateToNextPage(event)" toolTip="Go to next page"/>
												<mx:Image id="navLastPage"
														  source="{application.lastIcon}"
														  click="navigateToLastPage(event)" toolTip="Go to last page"
														  />
											</mx:HBox>
										</mx:ControlBar>
									</mx:Panel>
									<mx:Panel id="latTree" width="100%" height="100%" headerHeight="6" paddingBottom="4">
										<mx:HBox backgroundColor="0xDDDDDD" backgroundAlpha="0.7" width="100%" verticalAlign="top" 
												 paddingTop="3" paddingBottom="2" horizontalAlign="center">
											<mx:Image horizontalAlign="left" verticalAlign="middle" bottom="2"
													  source="{application.leftIcon}"
													  click="navigateDown(event)"
													  toolTip="Previous lexical entry"/>			
											<mx:Label htmlText="{dgList.selectedItem.listView.value}"
													  width="240"
													  textAlign="center" paddingTop="3" kerning="true" cachePolicy="off" condenseWhite="true"/>
											<mx:Image horizontalAlign="right" verticalAlign="middle" bottom="2"
													  source="{application.rightIcon}"
													  click="navigateUp(event)"
													  toolTip="Next lexical entry"/>
										</mx:HBox>
										<mpi:AutoSizeTree id="tree" width="100%" height="100%" horizontalScrollPolicy="auto"
														  dragMoveEnabled="false"
														  change="treeItemClicked(event)" labelField="label"
														  dataTipFunction="treeToolTip" showDataTips="true"
														  dragEnabled="true" dragEnter="onTreeDragEnter(event)"
														  dragOver="onTreeDragOver( event)"
														  dragDrop="onTreeDragDrop(event)"
														  itemRenderer="nl.mpi.lexus.LexiconTreeItemRenderer" />
										<mx:HBox width="100%" horizontalAlign="center" verticalAlign="bottom">
											<mx:Panel id="schemaElementsPanel" title="Add features" width="100%" height="30" verticalScrollPolicy="off"
													  rollOverEffect="showSchemaElementsPanel" rollOutEffect="hideSchemaElementsPanel">
												<mpi:AutoSizeList id="activeSchemaElements" labelField="name" allowDragSelection="false" 
																  iconFunction="getElementIconClass" width="100%"  dragMoveEnabled="false"
																  click="addSchemaElementToComponent(activeSchemaElements.selectedItem);"/>
											</mx:Panel>
											<mx:Image id="removeElementButton" verticalAlign="bottom" bottom="2"
													  source="{application.removeIcon}"
													  click="removeLIU(event)"
													  toolTip="Remove element"/>
										</mx:HBox>
									</mx:Panel>
								</mx:ViewStack>
							</mx:VBox>
							<mx:TabNavigator id="rightTabNav" width="75%" height="100%"
											 creationPolicy="all" change="rightTabChanged(event)"
											 backgroundAlpha="0.0">
								<mx:Canvas id="lexicalEntryEditor" label="Lexical entry" width="100%"
										   height="100%">
									<mx:HBox width="100%" height="22">
										
										<mx:Label text="Font:"/>
										<mx:ComboBox id="fontChooser" top="68" width="200" change="textFontChanged(event)" x="268"/>
										<mx:Label text="Size:"/>
										<mx:ComboBox id="fontSizeChooser" width="60" change="textFontChanged(event)">
											
											<mx:ArrayCollection>
												<mx:int>8</mx:int>
												<mx:int>9</mx:int>
												<mx:int>10</mx:int>
												<mx:int>11</mx:int>
												<mx:int>12</mx:int>
												<mx:int>14</mx:int>
												<mx:int>16</mx:int>
												<mx:int>18</mx:int>
												<mx:int>20</mx:int>
											</mx:ArrayCollection>
											
										</mx:ComboBox>
									</mx:HBox>
									<mx:VDividedBox width="100%" height="100%" y="30">
										<mx:Canvas id="editor" width="100%" height="80%"
												   verticalScrollPolicy="auto"/>
										<mx:TabNavigator width="100%" height="20%" creationPolicy="all"
														 change="propertyTabChanged(event)">
											<mx:Canvas id="multimediaTab" label="Multimedia"
													   width="100%" height="100%">
												<mx:Panel id="mediaPanel" title="Video" height="75%"
														  width="75%" horizontalAlign="center" paddingTop="10"
														  paddingLeft="10" paddingRight="10"
														  paddingBottom="10" visible="false">
													<mx:HBox>
														<mx:HBox id="videoPanel" height="75%" width="75%"
																 paddingTop="3" paddingLeft="3" paddingRight="3"
																 paddingBottom="3" visible="true"
																 horizontalAlign="center">
															<mx:Button icon="{application.zoomIconClass}"
																	   click="zoomImage(event)"/>
															<mx:Button id="importMM_button1" label="Modify"
																	   click="importResource()"/>
														</mx:HBox>
													</mx:HBox>
												</mx:Panel>
												<mx:VBox id="imagePanel" height="75%" width="75%"
														 paddingTop="3" paddingLeft="3" paddingRight="3"
														 paddingBottom="3" visible="false"
														 horizontalAlign="center">
													<mx:ProgressBar id="imgProgress" source="{image}"
																	visible="false" showEffect="Fade"
																	hideEffect="Fade"/>
													<mx:HBox width="100%" height="100%">
														<mx:Image id="image" maxHeight="100"
																  maxWidth="300" horizontalAlign="center"
																  completeEffect="Fade"
																  open="{imgProgress.visible=true}"
																  complete="{imgProgress.visible=false}"/>
														<mx:Button icon="{application.zoomIconClass}"
																   click="zoomImage(event)"/>
														<mx:Button id="importMM_button2" label="Modify"
																   click="importResource()"/>
													</mx:HBox>
												</mx:VBox>
												<mx:Panel id="audioPanel" title="Audio" height="75%"
														  width="75%" horizontalAlign="center" paddingTop="10"
														  paddingLeft="10" paddingRight="10"
														  paddingBottom="10" visible="false">
													<mx:Text width="75%" color="blue"
															 text="Use the buttons to control the audio. The Stop button resets the audio to the beginning."/>
													<mx:HBox>
														<mx:Button label="Play" click="playSound();"/>
														<mx:Button label="Pause" click="pauseSound();"/>
														<mx:Button label="Stop" click="stopSound()"/>
														<mx:Button id="importMM_button3" label="Modify"
																   click="importResource()"/>
													</mx:HBox>
												</mx:Panel>
												<mx:Panel id="uploadPanel" title="File upload"
														  height="75%" width="75%" horizontalAlign="center"
														  paddingTop="10" paddingLeft="10" paddingRight="10"
														  paddingBottom="10" visible="false">
													<mx:VBox>
														<mx:Image
															source="@Embed('../assets/images/icon-download.jpg')"/>
														<mx:Label
															text="This resource has been uploaded but not been activated yet. Use File->Save to save and activate this resource."/>
														<mx:Button label="Modify" click="importResource()"
																   />
													</mx:VBox>
												</mx:Panel>
												<mx:Panel id="importPanel" title="File upload"
														  height="75%" width="75%" horizontalAlign="center"
														  paddingTop="10" paddingLeft="10" paddingRight="10"
														  paddingBottom="10" visible="false">
													<mx:Button id="importMM_button4" label="Import"
															   click="importResource()"/>
												</mx:Panel>
												<mx:HBox id="urlPanel" height="75%" width="75%"
														 paddingTop="3" paddingLeft="3" paddingRight="3"
														 paddingBottom="3" visible="true"
														 horizontalAlign="center">
													<mx:Button icon="{application.zoomIconClass}"
															   click="zoomImage(event)"/>
													<mx:Button id="importMM_button5" label="Modify"
															   click="importResource()"/>
												</mx:HBox>
											</mx:Canvas>
											<mx:Canvas id="dataCategoryTab" label="Data category"
													   width="100%" height="100%">
												<mx:Grid width="100%">
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Name:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:Text id="dc_name"/>
														</mx:GridItem>
													</mx:GridRow>
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Description:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:Text id="dc_description"/>
														</mx:GridItem>
													</mx:GridRow>
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Admin Info:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:Text id="dc_adminInfo"/>
														</mx:GridItem>
													</mx:GridRow>
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Mandatory:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:CheckBox id="dc_mandatory" enabled="false"/>
														</mx:GridItem>
													</mx:GridRow>
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Multiples allowed:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:CheckBox id="dc_multiples" enabled="false"/>
														</mx:GridItem>
													</mx:GridRow>
											<!-- HHV: temporarily removed as requested by Menzo, since it's not really supported yet.
													<mx:GridRow>
														<mx:GridItem>
															<mx:Label text="Value domain:"/>
														</mx:GridItem>
														<mx:GridItem>
															<mx:Text id="dc_valuedomain"/>
														</mx:GridItem>
													</mx:GridRow>
													-->
												</mx:Grid>
											</mx:Canvas>
											<mx:Panel id="notesTab" label="Notes" width="100%"
													  height="10%" icon="{application.noteIcon}"
													  verticalAlign="bottom" horizontalAlign="left">
												<mx:TextArea id="notes" width="100%" height="100%"
															 change="updateNote()" alpha="0.7"
															 /> <!-- backgroundColor="#FFFF66" -->
											</mx:Panel>
										</mx:TabNavigator>
									</mx:VDividedBox>
								</mx:Canvas>
								<mx:Canvas id="lexicalEntryView" label="Lexical Entry View" width="100%" height="100%">
									<flexiframe:IFrame id="iFrame" x="10" y="10" width="90%" height="90%"/>
								</mx:Canvas>
								<!--
								<mx:Canvas id="vicos" label="Vicos" width="100%" height="100%">
								<mx:ModuleLoader url="modules/Vicos.swf" />
								</mx:Canvas>
								-->
							</mx:TabNavigator>
						</mx:HBox>
					</mx:Canvas>
					<QueryBuilder id="queryBuilder" label="Filters" width="100%" height="100%" texts_code= "filter"/>
				</mx:TabNavigator>
			</mx:Canvas>
		</mx:Panel>
	</mx:VBox>
	
</mx:Module>
