<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:mpi="nl.mpi.lexus.*"  width="400" height="300">
	<mx:Metadata> [Event(name="change", type="nl.mpi.lexus.event.SortOrderChangeEvent")] </mx:Metadata>
	<mx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import mx.collections.ArrayCollection;
			import mx.controls.TextInput;
			import mx.controls.listClasses.IListItemRenderer;
			import mx.core.FlexGlobals;
			import mx.events.DataGridEvent;
			import mx.events.ListEvent;
			import mx.formatters.SwitchSymbolFormatter;
			import mx.rpc.events.ResultEvent;
			
			import nl.mpi.lexus.LexusUtil;
			import nl.mpi.lexus.YesNo;
			import nl.mpi.lexus.event.SortOrderChangeEvent;
			import nl.mpi.lexus.service.LexusService;
		
			[Bindable]
			private var _sortOrder:Object;//The active sortOrder
			//
			[Bindable]
			public var sortOrderTemplates:Object; //The list of predefined sortOrders
			 
			private var lexusService:LexusService = new LexusService();
			
			public function set sortOrder( data:Object):void{
				sortOrderGrid.removeEventListener(DataGridEvent.ITEM_EDIT_END, this.onItemEditEnd);
				
				_sortOrder = data;
				sortOrderGrid.addEventListener(DataGridEvent.ITEM_EDIT_END, this.onItemEditEnd);

			}
			
			private function onJSONLoadSortOrders(event:ResultEvent):void {
				LexusUtil.parseJSON(String(event.result),
					function(data:Object):void {  
						sortOrderTemplates = data.result.sortOrders;
					}
				);
			}
			
			/**
			 * Refers to a temporary buffer soring the previously selected sortOrder
			 * This one will be validated on selection of focus changes.
			 **/
			private var prevOrder:Object;
			private function onItemEditEnd(event:DataGridEvent):void {
				var editor:TextInput = (sortOrderGrid.itemEditorInstance as TextInput);
				var txt:String = editor.text;
				switch( event.columnIndex){
					case 0:
						if( !this.validateStartLetter( editor.text)){
							sortOrderGrid.removeEventListener(DataGridEvent.ITEM_EDIT_END, this.onItemEditEnd);
							//Call preventDefault() so that the new value is NOT committed
							event.preventDefault();
							//Destroy the instance of the itemEditor by calling destroyEditor()						
							sortOrderGrid.destroyItemEditor();
							sortOrderGrid.addEventListener(DataGridEvent.ITEM_EDIT_END, this.onItemEditEnd);
							
						}
						break;
					case 1:
						if( !this.validateEquivalents( editor.text)){
							//Call preventDefault() so that the new value is NOT committed
							event.preventDefault();
							//Destroy the instance of the itemEditor by calling destroyEditor()	
							sortOrderGrid.destroyItemEditor();
							
						}
						
						var startLetter:String = this.sortOrderGrid.selectedItem.startLetter;
						if (startLetter.length > 1){
							startLetter = "[" + startLetter + "]";
						}
						
						if( editor.text.indexOf(startLetter) ==-1){
							//Call preventDefault() so that the new value is NOT committed
							event.preventDefault();
							//Destroy the instance of the itemEditor by calling destroyEditor()
							sortOrderGrid.destroyItemEditor();
							YesNo.alert("The startLetter must be present in the Characters list");
							
						}
						break;
				}
				//Dispatch change event
				if (!event.isDefaultPrevented()){
					var evnt:SortOrderChangeEvent = new SortOrderChangeEvent("change", this._sortOrder);
					dispatchEvent( evnt);
				}
			}
			
			private function info():void {
				YesNo.info("Drag and drop rules to reorder them.");
			}
			
			private function validateSortOrder( sortOrderRow:Object):void{
				this.validateStartLetter( sortOrderRow.startLetter);
			}
			
			
			
			private var STATE_KEY:int = 1;
			private var STATE_KEY_ESCAPED:int = 2;
			private var STATE_KEY_OPENED:int =  3;
		
			private var STATE_MULTI_KEY:int =  6;
			private var STATE_MULTI_KEY_ESCAPED:int =  7;
			private var STATE_MULTI_KEY_OPENED:int =  8;
			private var STATE_INNER_MULTI_KEY_ESCAPED:int =  9;


			private function validateStartLetter(text:String):Boolean{
				//value entered in the text field must be filtered
				//on illegal characters.
				//In essence the way a start letter field works is that the value of this field will be surrounded by [] when it hits the server.
				//Furthermore no \, [, ], ( or ) characters are allowed, except if they are preceded by a \ character.
				
				var args:Array;
				
				if( text == null || text.length == 0){
					YesNo.alert(MESSAGE_NO_CHARACTER);
					return false;
				}
					
				var state:int = this.STATE_KEY;
				var key:String=null;
				var isValid:Boolean = true;
				for (var i:int=0;i<text.length;i+=1) {
					if( !isValid)
						break;
					
					var letter:String = text.substring(i,i+1);

					switch( state){
						case this.STATE_KEY:
							if (letter=="\\")
								state=this.STATE_KEY_ESCAPED;
							else {
								if( this.isSpecialCharacter( letter)){
									isValid = false;
									args = new Array();
									args[0] = text;
									args[1] = letter;
									args[2] = this.getSpecialCharacters();
									YesNo.alert(constructMessage(MESSAGE_NOT_SPECIAL_CHARACTER, args));
								} 
								key=letter;
							}
							break;
						case STATE_KEY_ESCAPED:
							if( !this.isSpecialCharacter( letter)){
								isValid = false;
								args = new Array();
								args[0] = text;
								args[1] = letter;
								args[2] = this.getSpecialCharacters();
								YesNo.alert(constructMessage(MESSAGE_SPECIAL_CHARACTER, args));
							} 
							key=letter;
							state=this.STATE_KEY;
							break;
					}
				}
				
				if( state != STATE_KEY){
					this.showStateMessage(state);
					isValid = false;
				}
				return isValid;
			}	
			
			private function validateEquivalents( text:String):Boolean{
				if( text.indexOf(" ") != -1){
					YesNo.alert("Whitespaces are not allowed here");
					return false;
				}
				
				var state:int = this.STATE_KEY;
				var key:String=null;
				var isValid:Boolean = true;
				for (var i:int=0;i<text.length;i+=1) {
					if( !isValid)
						break;
					var letter:String = text.substring(i,i+1);
					switch( state){
						case this.STATE_KEY:
							if (letter=="\\")
								state=this.STATE_KEY_ESCAPED;
							else if( letter == "[")
								state = STATE_MULTI_KEY;
							else {
								if( this.isSpecialCharacter( letter)){
									isValid = false;
									var args:Array = new Array();
									args[0] = text;
									args[1] = letter;
									args[2] = this.getSpecialCharacters();
									YesNo.alert(this.constructMessage( this.MESSAGE_NOT_SPECIAL_CHARACTER, args));
								} 
								key=letter;
							}
							break;
						case STATE_KEY_ESCAPED:
							if( !this.isSpecialCharacter( letter)){
								isValid = false;
								args = new Array();
								args[0] = text;
								args[1] = letter;
								args[2] = this.getSpecialCharacters();
								YesNo.alert(this.constructMessage( this.MESSAGE_SPECIAL_CHARACTER, args));
							} 
							key=letter;
							state=this.STATE_KEY;
							break;
						case STATE_MULTI_KEY:
							if( letter == "\\")
								state = this.STATE_MULTI_KEY_ESCAPED;
							else if( letter == "]")
								state = this.STATE_KEY;
							else{
								if( this.isSpecialCharacter( letter)){
									isValid = false;
									args = new Array();
									args[0] = text;
									args[1] = letter;
									args[2] = this.getSpecialCharacters();
									YesNo.alert(this.constructMessage( this.MESSAGE_NOT_SPECIAL_CHARACTER, args));
								} 
							}
							break;
						case STATE_MULTI_KEY_ESCAPED:
							if( !this.isSpecialCharacter( letter)){
								isValid = false;
								//this.sortOrderGrid.selectedItem = sortOrderRow;
								args = new Array();
								args[0] = text;
								args[1] = letter;
								args[2] = this.getSpecialCharacters();
								YesNo.alert(this.constructMessage( this.MESSAGE_SPECIAL_CHARACTER, args));
							} 
							state = this.STATE_MULTI_KEY; 
							break;
					}
				}
				if( state != STATE_KEY){
					this.showStateMessage( state);
					isValid = false;
				}
				return isValid;
			}
					
			private var MESSAGE_NOT_SPECIAL_CHARACTER:String = "You have entered a value {0} which should not contain a reserved character ({1}) at this point. Reserved characters are {2}. To include reserved characters please prepend a \\ to {1}";
			private var MESSAGE_SPECIAL_CHARACTER:String = "You have entered a value {0} which should contain a reserved character ({1}) at this point. Reserved characters are {2}. Possibly you will need to remove the \\ preceding the {1} character";
			private var MESSAGE_NO_CHARACTER:String = "You must supply at least one character."
			private var MESSAGE_ESCAPE_STATE:String = "You must supply a character to escape at at the end."
			private var MESSAGE_MULTIKEY_STATE:String = "You must supply at least a ] character at the end."
			
			private function constructMessage( messageTemplate:String, args:Array):String{
				var message:String = messageTemplate;
				if( args == null)
					return message;
					
				for( var i:int = 0; i < args.length; i++){
					var argIdentifier:String = "{" + i + "}";
					while( message.indexOf( argIdentifier) != -1)
						message= message.replace( argIdentifier, args[i]);
				}
				return message;
			}
			
			private function showStateMessage( state:int):void{
				switch (state){
					case STATE_KEY_ESCAPED:
						YesNo.stop(MESSAGE_ESCAPE_STATE);
						break; 
					case STATE_MULTI_KEY_ESCAPED:
						YesNo.stop(MESSAGE_ESCAPE_STATE);
						break; 	
					case STATE_MULTI_KEY:
						YesNo.stop(MESSAGE_MULTIKEY_STATE);
						break;
				}
			}
			
			/**
			 * Indicates whether the specified letter String containing any reserved characters
			 **/
			private function isSpecialCharacter( letter:String):Boolean{
				return this.getSpecialCharacters().indexOf( letter)!=-1;
			}
			
			/**
			 * Returns the String containing all reserved characters
			 **/
			private function getSpecialCharacters():String{
				return "()\\[]";
			}
			
			private function createNewSortOrderRow():void{
				var idx:int = (sortOrderGrid.selectedIndex != -1)?sortOrderGrid.selectedIndex:0;
				var sortOrderRow:Object = new Object();
				sortOrderRow.startLetter = "";
				sortOrderRow.characters = "";
				
				if( this._sortOrder.data == null)
					this._sortOrder.data = new ArrayCollection();
				(sortOrderGrid.dataProvider as ArrayCollection).addItemAt( sortOrderRow, idx);
				dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder));
			}
			
			private function removeSortOrderRow():void{
				var idx:int = sortOrderGrid.selectedIndex;
				if( idx >-1)
					(sortOrderGrid.dataProvider as ArrayCollection).removeItemAt(idx);
				dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder));
			}
			
			private function clearSortOrderRows():void{
				(sortOrderGrid.dataProvider as ArrayCollection).removeAll();
				dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder));
			}			
		]]>
	</mx:Script>
	
	<mx:VBox width="96%" height="100%">
		<mx:HBox width="100%">
			<mx:VBox width="10%" left="10">
				<mx:Label text="Name:"/>
				<mx:Label text="Description:"/>
			</mx:VBox>
			<mx:VBox width="70%" left="10">
				<mx:TextInput id="sortorder_name" width="100%" change="dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder))"/>
				<mx:TextArea id="sortorder_description" width="100%" change="dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder))"/>
			</mx:VBox>
		</mx:HBox>
		<mx:Panel width="100%" height="100%">
			<mx:VBox id="mainPanel" width="100%" height="100%" horizontalAlign="left"
				paddingLeft="10">
				<mx:HBox id="gridBox" width="100%" height="100%" horizontalAlign="left">
					<mpi:SelectableDataGrid id="sortOrderGrid" width="100%" height="100%" editable="true" dragDrop="dispatchEvent(new SortOrderChangeEvent('change', this._sortOrder))"
											dataProvider="{this._sortOrder.data}" sortableColumns="false" dragEnabled="true" dropEnabled="true" dragMoveEnabled="true">
						<mpi:columns>
							<mx:DataGridColumn headerText="Start letter" dataField="startLetter"/>
							<mx:DataGridColumn headerText="Characters" dataField="characters"/>
						</mpi:columns>
					</mpi:SelectableDataGrid>
				</mx:HBox>
			</mx:VBox>
			<mx:ControlBar horizontalAlign="left" width="100%">
				<mx:Image source="{FlexGlobals.topLevelApplication.addIcon}" click="createNewSortOrderRow()"
					toolTip="Add"/>
				<mx:Image source="{FlexGlobals.topLevelApplication.removeIcon}" click="removeSortOrderRow()"
					toolTip="Remove"/>
				<mx:Spacer width="100%"/>
				<mx:Image source="{FlexGlobals.topLevelApplication.infoIcon}" click="info()"
					toolTip="Info"/>
				<mx:Image source="{FlexGlobals.topLevelApplication.trashIcon}" click="clearSortOrderRows()"
					toolTip="Remove all rules"/>
			</mx:ControlBar>
		</mx:Panel>
	</mx:VBox>
	
	<mx:Binding destination="sortorder_name.text" source="this._sortOrder.name"/>
	<mx:Binding destination="this._sortOrder.name" source="sortorder_name.text"/>
	<mx:Binding destination="sortorder_description.text" source="this._sortOrder.description"/>
	<mx:Binding destination="this._sortOrder.description" source="sortorder_description.text"/>
</mx:Canvas>
