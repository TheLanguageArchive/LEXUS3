<?xml version="1.0" encoding="utf-8"?>
<mx:Panel xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" xmlns:lexus="nl.mpi.lexus.*"
		  initialize="ToolTipManager.enabled = true;">		
	<mx:Script>
		<![CDATA[
			import flexlib.controls.Highlighter;
			
			import mx.collections.XMLListCollection;
			import mx.controls.listClasses.IListItemRenderer;
			import mx.core.DragSource;
			import mx.core.FlexGlobals;
			import mx.core.IUIComponent;
			import mx.core.UIComponent;
			import mx.events.DragEvent;
			import mx.events.DropdownEvent;
			import mx.events.ListEvent;
			import mx.events.ListEventReason;
			import mx.events.ToolTipEvent;
			import mx.events.TreeEvent;
			import mx.managers.DragManager;
			import mx.managers.PopUpManager;
			import mx.managers.ToolTipManager;
			import mx.messaging.messages.HTTPRequestMessage;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.http.HTTPService;
			import mx.utils.ObjectUtil;
			import mx.utils.StringUtil;
			
			import nl.mpi.lexus.LexusUtil;
			import nl.mpi.lexus.YesNo;
			import nl.mpi.lexus.event.ValueChangeEvent;
			import nl.mpi.lexus.event.ViewChangeEvent;
			import nl.mpi.lexus.service.LexusService;
			import nl.mpi.lexus.view.NodeEditor;
			import nl.mpi.lexus.view.NodeRenderer;
			
			private const SHOW_STYLE_EDITOR_LABEL:String = "Show style editor";
			private const SHOW_STRUCTURE_EDITOR_LABEL:String = "Show structure editor";
			private const SHOW_XML_DATA_LABEL:String = "Show source";
			private const EDITORXOFFSET:int = 40;
			private const EDITORYOFFSET:int = 20;
						
			[Bindable] public var lexiconId:String;
			private var _schemaElementsTree:AutoSizeTree = null;
			
			private var _newView:XML =
				<view name="What a view!" description="It's a great view." type="dsl_view">
					<style type="dsl_style"/>
					<structure isBranch="true" type="dsl_structure"/>
				</view>;
			[Bindable] private var _viewXML:XML = null;
				
			[Bindable] private var viewElements:XML = 
			<elements>
				<element label="Decorator" type="dsl_show" icon="folderClosedIcon"/>
				<element label="Text" type="dsl_text" icon="defaultLeafIcon"/>
				<element label="Table" type="dsl_table" icon="folderClosedIcon">
					<element label="Row" type="dsl_table_row" icon="folderClosedIcon"/>
					<element label="Column" type="dsl_table_column" icon="folderClosedIcon"/>
				</element>
			</elements>;
			
			private var _modified:Boolean;
			
			private var dragSourceSelectedItem:XML = null;

			public var dragSourceFromSchemaEditor:Object = null;

			// Remember the previous deny/accept rule,no need to print a rule if it's the same as the previous.
			private var previousRule:String = "";
			
			// Define public getter.
			public function get viewXML():XML {
				return _viewXML;
			}
			
			// Define public setter. 
			public function set viewXML(value:XML):void {
				_viewXML = value;
				needsSave = false;
				structureTree.validateNow();
				callLater(structureTree.expandChildrenOf, [_viewXML, true]);
			}
			
			
			// Define public setter. 
			public function get schemaElementsTree():AutoSizeTree {
				return _schemaElementsTree;
			}
			
			// Define public setter. 
			public function set schemaElementsTree(value:AutoSizeTree):void {
				_schemaElementsTree = value;
			}
			
			// Define public getter.
			public function newView(_lexiconId:String):XML {
				_viewXML = ObjectUtil.copy(_newView) as XML;
				needsSave = true;
				this.lexiconId = _lexiconId;
				structureTree.validateNow();
				callLater(structureTree.expandChildrenOf, [_viewXML, true]);
				return _viewXML;
			}
			
			public function get needsSave():Boolean {
				return this._modified;
			}
			
			public function set needsSave(value:Boolean):void {
				this._modified = value;
			}
			
			private function onKeyUp(event:KeyboardEvent):void
			{
				if (event.keyCode == 46)
				{
					var item:XML = XML(structureTree.selectedItem);
					var parent:XML = item.parent();
					if (parent != _viewXML) {
						var index:int = item.childIndex();
						delete (parent.*[index]);
						needsSave = true;
						structureTree.invalidateList();
						
					}
				}
			}
			
			private function fixedInt(value:int, mask:String):String {
				return String(mask + value.toString(16)).substr(-mask.length).toUpperCase();
			}
			
			/* Process the data from the NodeEditor after Cancel */
			public function cancelDataEdit(event:ValueChangeEvent):void {
				
				// Allow interaction again when the popup is gone.
				this.enabled = true;
				
				event.preventDefault();
				
			}
			
			/* Process the data from the NodeEditor after Ok */
			public function processEditedData(event:ValueChangeEvent):void {    
				
				// Allow interaction again when the popup is gone.
				this.enabled = true;
				
				event.preventDefault();
				
				var item:XML = structureTree.selectedItem as XML;
				
				if (item.@type == 'dsl_text') {
					var te:TextEditor = TextEditor(event.value);
					
					// Get new text before from editor.
					if (item.@value != te.text_value.text) { 
						item.@value = te.text_value.text;
						needsSave = true;
					}
					if (item.@dsl_class != te.dsl_class_attribute_value.text) { 
						item.@dsl_class = te.dsl_class_attribute_value.text;
						needsSave = true;
					}
				}
				
				else if (item.@type == 'dsl_show') {
					var ce:DecoratorEditor = DecoratorEditor(event.value);
					var color:String = "0x" + fixedInt(ce.show_cp.selectedColor, '000000');
					var ff:String = ce.show_fontFamily.selectedItem.fontName;
					var fs:String = ce.show_fontSize.selectedItem as String;
					var dc:String = ce.dsl_class_attribute_value.text;
					var optional:String = ce.optional.selected ? "true" : "false" as String;
					var block:String = ce.block.selected ? "true" : "false" as String;
					var localStyle:String = ce.localStyle.selected ? "false" : "true" as String;

					// Get new color from editor.
					if (item.@color != color ||
						item.@fontFamily != ff ||
						item.@fontSize != fs ||
						item.@dsl_class != dc ||
						item.@optional != optional ||
						item.@block != block ||
						item.@localStyle != localStyle) {
						needsSave = true;
					}
					item.@color = color;
					item.@fontFamily = ff;
					item.@fontSize = fs;
					item.@dsl_class = dc;
					item.@optional = optional;
					item.@block = block;
					item.@localStyle = localStyle;
				}
				else if (item.@type == 'dsl_table' || item.@type == 'dsl_table_row') {
					var cloe:ClassOptionalEditor = ClassOptionalEditor(event.value);
					// Get new dsl_class attribute from editor.
					if (item.@dsl_class != cloe.dsl_class_attribute_value.text) { 
						item.@dsl_class = cloe.dsl_class_attribute_value.text;
						needsSave = true;
					}
					if (item.@optional != cloe.optional.selected ? "true" : "false") {
						item.@optional = cloe.optional.selected ? "true" : "false";
						needsSave = true;
					}
				}
				else {
					var cle:ClassEditor = ClassEditor(event.value);
					// Get new dsl_class attribute from editor.
					if (item.@dsl_class != cle.dsl_class_attribute_value.text) { 
						item.@dsl_class = cle.dsl_class_attribute_value.text;
						needsSave = true;
					}
				}

				this.validateNow();
				callLater(structureTree.expandChildrenOf, [structureTree.dataProvider, true]);

			}
			
			/**
			 * Attempts to store the view to the server.
			 **/
			public function save():void {
				var lexusService:LexusService = new LexusService();
				lexusService.sendXMLAndParseXML("LexusSchemaEditor/saveView.xml?lexiconId="+this.lexiconId, this._viewXML,
					function(data:XML):void {
						var success:String = data.@success;
						var done:Boolean = success == "true";
						if (done) {
							var view:XML = data.view[0];
							dispatchEvent(new ViewChangeEvent(ViewChangeEvent.SAVED_VIEW, view));
							needsSave = false;
						}
					}
				);
			}
			
			/**
			 * Discards the view.
			 **/
			public function discard():void {
				_viewXML = null;
				this.validateNow();
			}
			
			private function nameUpdate():void {
				needsSave = true;
				_viewXML.@name = View_name.text
			}
			
			private function descriptionUpdate():void {
				needsSave = true;
				_viewXML.@description = View_description.text
			}
			
			
			private function dragEnterHandler(event:DragEvent):void {
				structureTree.hideDropFeedback(event);				
				// Explicitly handle the dragDrop event.           
				event.preventDefault();
				DragManager.acceptDragDrop(Tree(event.target));

			}
			
			
			private function doDragOver(event:DragEvent):void
			{
				var dragInitiator:IUIComponent = event.dragInitiator;
				
				var dragSource:Object = dragSourceSelectedItem != null ? dragSourceSelectedItem
					: dragSourceFromSchemaEditor != null ? dragSourceFromSchemaEditor : null;
				
				
				// Explicitly handle the dragDrop event.           
				event.preventDefault();

				// Tell Flex to show the drop feedback
				// structureTree.hideDropFeedback(event);
				// event.currentTarget.showDropFeedback(event);

				// Get drop target.
				var dropTarget:Tree = event.currentTarget as Tree;
				
				// Get the drop location.
				var dropLoc:int = dropTarget.calculateDropIndex(event);			
				structureTree.selectedIndex = dropLoc; 
				var dropElement:XML = structureTree.selectedItem as XML;
				
				
				// If drag source is an element from the schema..
				if (dragInitiator == _schemaElementsTree) {
					if (isDC(dragSource)) {
						//  datacategory goes on columns, decorators or the view.
						if (isTableColumn(dropElement) || isDecorator(dropElement) || isViewStructure(dropElement)) {
							acceptDrop(dropTarget, event, "1.1");
						}
						else
							denyDrop(event, "1.2"); 
					}
					else
						acceptDrop(dropTarget, event, "1.3");
				}
				
					
				//Text can be dropped on Columns, Decorators and the View-structure.
				else if (isText(dragSource)) {
					if (isTableColumn(dropElement) || isDecorator(dropElement) || isViewStructure(dropElement)) {
						acceptDrop(dropTarget, event, "10.1");
					}
					else 
						denyDrop(event, "10.2"); 
				}
					
				//Decorators can be dropped on Columns, Decorators and the View-structure.
				else if (isDecorator(dragSource)) {
					if (isViewStructure(dropElement)) {
						acceptDrop(dropTarget, event, "11.1");
					}
					else if (isTableColumn(dropElement) || isDecorator(dropElement)) {
						acceptDrop(dropTarget, event, "11.2");
					}
					else 
						denyDrop(event, "11.3"); 
				}
				
				
				//Columns can be dropped on rows
				else if (isTableColumn(dragSource)) {
					if (isTableRow(dropElement)) {
						acceptDrop(dropTarget, event, "8.1");
					}
					else 
		                denyDrop(event, "8.2"); 
				}
				
					
				//Rows can be dropped on (container/decorator descendants of) table header and table body elements.
				else if (isTableRow(dragSource)) {
					if ((isDecendantOfTableHeader(dropElement) || isDecendantOfTableBody(dropElement)) &&
						(isTableHeader(dropElement) || isTableBody(dropElement) || isContainer(dropElement) || isDecorator(dropElement))) {
						acceptDrop(dropTarget, event, "9.1");
					}
					else 
						denyDrop(event, "9.2"); 
				}
				
				//Table, Decorator, SchemaElement, Text can be dropped on a column
				else if (isTableColumn(dropElement)) {
					if (isTable(dragSource) || isDC(dragSource) || isSchemaElement(dragSource) || isText(dragSource)) {
						acceptDrop(dropTarget, event, "2.1");
					}
				}
				
				// Drop only columns on rows.
				else if (isTableRow(dropElement)) {
					if (isTableColumn(dragSource)) {
						acceptDrop(dropTarget, event, "3.1");
					}
					else
		                denyDrop(event, "3.2"); 
				}
				
				// If drop target an element from the schema view.
				else if (isSchemaElement(dropElement)) {
					// Don't drop anything on a datacategory except a new decorator
					if (isDC(dropElement)) {
						if (isDecorator(dragSource) && dragInitiator == Vtree) {
							acceptDrop(dropTarget, event, "4.1");
						}
						else
			                denyDrop(event, "4.2"); 
					}
					else if (isContainer(dropElement)) {
						acceptDrop(dropTarget, event, "4.3");
					}	
				}
					
				
				// Body and Head can take rows and Containers.
				else if (isTableHeader(dropElement) || isTableBody(dropElement)) {
					if (isTableRow(dragSource) || isContainer(dropElement)) {
						acceptDrop(dropTarget, event, "5.1");
					}
					else
						denyDrop(event, "5.2");
				}
				
				
				// Tables cannot be dropped on.
				else if (isTable(dropElement)) {
	                denyDrop(event, "6.1"); 
				}
			
			
				else if (dropElement.@isBranch == 'true') {
					acceptDrop(dropTarget, event, "7.1");
				}
				else {	
	                denyDrop(event, "7.2"); 
				}
			}
			
			/**
			 * Return COPY or MOVE depending on the Ctrl key.
			 * */
			private function copyOrMove(event:DragEvent):String {
				if (event.ctrlKey) {
					return DragManager.COPY;
				} else {
					return DragManager.MOVE;
				}
			}
			
			
			/**
			 * Accept a drop.
			 * */
			private function acceptDrop(dropTarget:Tree, event:DragEvent, rule:String):void {
				if (previousRule != rule) {
					trace("Accept drop, rule: #"+rule);
					previousRule = rule;
				}
				DragManager.acceptDragDrop(dropTarget);
				DragManager.showFeedback(copyOrMove(event));
			}

			/**
			 * Deny a drop.
			 * */
			private function denyDrop(event:DragEvent, rule:String):void {
				if (previousRule != rule) {
					trace("Deny drop, rule: #"+rule);
					previousRule = rule;
				}
				DragManager.showFeedback(DragManager.NONE);
			}

			/**
			 * True if it is the structure element.
			 * */
			private function isViewStructure(element:XML):Boolean {
				return (isElementFromView(element) && element.@type == 'dsl_structure') || element.localName() == 'structure';
			}
			
			/**
			 * True if it is a table element.
			 * */
			private function isTable(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_table';
			}
			
			/**
			 * True if it is a table header element.
			 * */
			private function isTableHeader(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_table_heading';
			}
			
			/**
			 * True if it is a table body element.
			 * */
			private function isTableBody(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_table_body';
			}
			
			
			/**
			 * True if the element or one of it's parents is a table header element.
			 * */
			private function isDecendantOfTableHeader(element:XML):Boolean {
				if (isTableHeader(element))
					return true;
				else
					if (element.parent() == null)
						return false;
					else
						return isDecendantOfTableHeader(element.parent());
			}
			
			/**
			 * True if the element or one of it's parents is a table body element.
			 * */
			private function isDecendantOfTableBody(element:XML):Boolean {
				if (isTableBody(element))
					return true;
				else
					if (element.parent() == null)
						return false;
					else
						return isDecendantOfTableBody(element.parent());
			}
			
			/**
			 * True if it is a table row element.
			 * */
			private function isTableRow(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_table_row';
			}
			
			/**
			 * True if it is a table column element.
			 * */
			private function isTableColumn(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_table_column';
			}
			
			/**
			 * True if it is a Decorator element.
			 * */
			private function isDecorator(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_show';
			}
			
			/**
			 * True if it is a Text element.
			 * */
			private function isText(element:Object):Boolean {
				return isElementFromView(element) && element.@type == 'dsl_text';
			}
			
			/**
			 * True if it is an element from the schema.
			 * */
			private function isSchemaElement(element:Object):Boolean {
				return element.hasOwnProperty("type");
			}
			
			
			/**
			 * True if it is an element from the view itself.
			 * */
			private function isElementFromView(element:Object):Boolean {
				return element.hasOwnProperty("@type");
			}
			/**
			 * True if it is a container element.
			 * */
			private function isContainer(element:Object):Boolean {
				if ((isSchemaElement(element) && (element.type == 'container' || element.type == 'component'))
					|| element.@type == 'container') {
						return true;
					}
				return false;
			}
			
			/**
			 * True if it is a data category element.
			 * */
			private function isDC(element:Object):Boolean {
				if ((isSchemaElement(element) && element.type == 'data category')
					|| element.@type == 'data category') {
						return true;
				}
				return false;
			}
			
			
			
			private function doDragExit(event:DragEvent):void
			{
				dragSourceSelectedItem = null;
				structureTree.validateNow();
				callLater(structureTree.expandChildrenOf, [_viewXML, true]);
			}
			
			private function doDragComplete(event:DragEvent):void
			{
				dragSourceSelectedItem = null;
				structureTree.validateNow();
				callLater(structureTree.expandChildrenOf, [_viewXML, true]);
			}
			
			private function dragDropHandler(event:DragEvent):void {				
				var dragInitiator:IUIComponent = event.dragInitiator;
				var dragSource:DragSource = event.dragSource;
				// Get drop target.
				var dropTarget:Tree = event.currentTarget as Tree;
				// Get the drop location in the destination.
				var dropLoc:int = dropTarget.calculateDropIndex(event);				
				structureTree.selectedIndex = dropLoc; 
				var dropElement:XML = structureTree.selectedItem as XML;
				// Get the dragged item from the drag initiator.
				// The List control always writes an Array 
				// to the dragSource object,
				// even if there is only one item being dragged.
				var itemsArray:Array = event.dragSource.dataForFormat("treeItems") as Array;
				var item:Object = itemsArray[0];

				// Explicitly handle the dragDrop event.           
				event.preventDefault();
				
				/*
				* Drag and drop within the tree is rudimentary handled by us.
				*/
				
				if (dragInitiator == structureTree) {
					if (event.action == DragManager.MOVE) {
						var children:XMLList = XMLList(dragSourceSelectedItem.parent().children());
						for (var i:Number=0; i < children.length(); i++) {
							if (children[i] == dragSourceSelectedItem) {
								delete children[i];
							}
						}
					}
					dropElement.appendChild(dragSourceSelectedItem);
					needsSave = true;
					structureTree.invalidateList();
					return;
				}				
				
				if (item.hasOwnProperty("@type")) {
					if (item.@type == 'dsl_show') {
						var show:XML = <show/>;
						show.@type = item.@type;
						show.@name = 'Decorator';
						show.@color = '#000000';
						show.@fontSize = '12pt';
						show.@fontFamily = '';
						show.@isBranch = true;
						addDraggedObject(dropElement, show);
					}
					
					else if (item.@type == 'dsl_text') {
						var text:XML = <text name="text" value="" isBranch="false"/>;
						text.@type = item.@type;
						addDraggedObject(dropElement, text);
					}				
					
					else if (item.@type == 'dsl_table') {
						var table:XML = <table type="dsl_table" name="Table" isBranch="true">
											<thead name="header" type="dsl_table_heading" isBranch="true">
												<row type="dsl_table_row" isBranch="true" name="row">
													<col type="dsl_table_column" name="column" isBranch="true"/>
												</row>
											</thead>
											<tbody name="body" type="dsl_table_body" isBranch="true">
												<row type="dsl_table_row" name="row" isBranch="true">
													<col type="dsl_table_column" name="column" isBranch="true"/>
												</row>
											</tbody>
										</table>;
						addDraggedObject(dropElement, table);
					}
					
					else if (item.@type == 'dsl_table_row') {
						var row:XML = <row type="dsl_table_row" name="row" isBranch="true"/>;
						addDraggedObject(dropElement, row);
					}
					
					else if (item.@type == 'dsl_table_column') {
						var col:XML = <col type="dsl_table_column" name="column" isBranch="true"/>;
						addDraggedObject(dropElement, col);
					}					
				}
				else {
					if (item.hasOwnProperty("type")) {
						if (item.type == 'data category') {
							var data:XML = <data/>;
							data.@id = item.id;
							data.@name = item.name;
							data.@type = item.type;
							data.@isBranch = false;
							addDraggedObject(dropElement, data);
						}
						// UI uses component instead of container, just match both now
						else if (item.type == 'container' || item.type == 'component') {
							var list:XML = <list/>;
							list.@id = item.id;
							list.@name = item.name;
							list.@type = "container";
							list.@isBranch = true;
							addDraggedObject(dropElement, list);
						}
					}
				}
				this.validateNow();
				callLater(structureTree.expandChildrenOf, [_viewXML, true]);
			}
			
			/*
			* If dropElement.@isBranch == true then add draggedElement at end of dropElement's children.
			*/
			private function addDraggedObject(dropElement:XML, draggedElement:XML):void {
				if (dropElement.@isBranch == 'true') {
					dropElement.appendChild(draggedElement);
					needsSave = true;
					this.validateNow();
				}
			}		


			private function changeHandler(event:MouseEvent):void {
				var popup:Object;
				var item:XML = event.currentTarget.selectedItem as XML;
				if (item.@type == 'dsl_show') { 
					popup = DecoratorEditor(PopUpManager.createPopUp(this, DecoratorEditor, false));
				}
				else if (item.@type == 'dsl_text') { 
					popup = TextEditor(PopUpManager.createPopUp(this, TextEditor, false));
				}
				else if (item.@type == 'dsl_table' || item.@type == 'dsl_table_row') { 
					popup = ClassOptionalEditor(PopUpManager.createPopUp(this, ClassOptionalEditor, false));
				}
				else if (item.@type == 'dsl_view') { 
					
				}
				else { 
					popup = ClassEditor(PopUpManager.createPopUp(this, ClassEditor, false));
				}
				popup.addEventListener(NodeEditor.NODE_EDITOR_FINISHED, this.processEditedData);
				popup.addEventListener(NodeEditor.NODE_EDITOR_CANCELLED, this.cancelDataEdit);
				popup.data = item;
				// position the window a little to the right and above the selected item
	            var pt:Point = new Point(structureTree.selectedItem.x, structureTree.selectedItem.y);
	            pt = event.target.localToGlobal(pt);
	            popup.x = pt.x + EDITORXOFFSET;
	            popup.y = pt.y - EDITORYOFFSET;
				// Disable interaction while the popup is there.
				this.enabled = false;
			}
			
			
			private function dataTips(data:XML):String {
				var drag:String = "Drag from the '" + StructEltsPanel.title + "' list. Drag elements from the lexicon."
				if (data.@type == 'dsl_show') {
					return "Double click to choose font, color, etc. " + drag;
				}
				if (data.@type == 'dsl_text') {
					return "Double click to edit the text.";
				}
				if (data.@type == 'data category') {
					return "This is a data field from the lexicon. Use a Decorator element to decorate it, surround it with text, etc.";
				}
				if (data.@type == 'container') {
					return "This is a container field from the lexicon. " + drag;
				}
				return "";
			}
			
			private function showStyleHelp(showIt:Boolean):void {
				styleHelp.visible = showIt;
				styleHelp.includeInLayout = showIt;
			}
			private function showHelp(showIt:Boolean):void {
				help.visible = showIt;
				help.includeInLayout = showIt;
			}
			private function initializeStyleEditor(event:MouseEvent):void {
					var style:String = styleEditor.text;
					if (style == "") {
						style = "\nbody {\n\tfont-family: sans-serif;\n\tfont-size: 12pt;\n\tbackground-color: #EEEEEE;\n\tcolor: black;\n}\n";
						style += getExistingClassesAsCSS(_viewXML.structure);
						styleEditor.text = style;
						updateStyleInViewXML();
					}
			}
			
			private function updateStyleInViewXML():void {
				_viewXML.style = styleEditor.text;
				needsSave = true;
			}
			
			private function addStylesForClasses(event:MouseEvent):void {
				var style:String = styleEditor.text;
				var currentStyle:String = StringUtil.trimArrayElements(style, "");
				style += getExistingClassesAsCSS(new XML(_viewXML.structure), currentStyle);
				styleEditor.text = style;
				updateStyleInViewXML()
				this.validateNow();
			}
			/*
			 * Go through the XML and add CSS declarations for classes that do not
			 * have a CSS declaration yet.
			 * To check if a class already has a declaration in the style a 
			 * regular expression ".<class>"is used.
			 */
			private function getExistingClassesAsCSS(node:XML, currentStyle:String = ""):String {
				var child:XML;
				var css:String = "";
				if (node.hasOwnProperty("@dsl_class") && node.@dsl_class != "") {
					var pattern:RegExp = new RegExp("."+node.@dsl_class, "i");
					if (currentStyle.search(pattern) < 0) { // class does not have CSS selector yet.
						css = css + "\n." + node.@dsl_class + " {\n\n}\n";
					}
				}
				for each(child in node.children())  {
					css = css + getExistingClassesAsCSS(child, currentStyle);
				}
				return css;
			}
			
			private function stylesHelp(event:MouseEvent):void {
				var httpService:LexusService = new LexusService();
				httpService.send("help/viewEditorStylingHelp.html", null, null, function(evt:ResultEvent):void {
					styleHelp.htmlText =  new String(evt.result);
				});

				if (styleHelp.visible) {
					showStyleHelp(false);
				}
				else {
					showStyleHelp(true);
				}
			}
			
			
			private function viewEditorHelp(event:MouseEvent):void {
				var httpService:LexusService = new LexusService();
				httpService.send("help/viewEditorHelp.html", null, null, function(evt:ResultEvent):void {
					help.htmlText =  new String(evt.result);
				});
				if (help.visible) {
					showHelp(false);
				}
				else {
					showHelp(true);
				}				
			}

			
			private function viewTree_iconFunc(item:XML):Class {
				var type:String = item.@type;
				switch (type) {
					case 'dsl_show': return FlexGlobals.topLevelApplication.decoratorIcon;
					case 'dsl_text': return FlexGlobals.topLevelApplication.documentIcon;
					case 'data category': return FlexGlobals.topLevelApplication.dataCategoryIcon;
					case 'container': return FlexGlobals.topLevelApplication.containerIcon;
					case 'dsl_table': return FlexGlobals.topLevelApplication.tableIcon;						
					case 'dsl_table_heading': return FlexGlobals.topLevelApplication.tableHeadIcon;						
					case 'dsl_table_body': return FlexGlobals.topLevelApplication.tableBodyIcon;						
					case 'dsl_table_row': return FlexGlobals.topLevelApplication.tableRowIcon;						
					case 'dsl_table_column': return FlexGlobals.topLevelApplication.tableColumnIcon;						
				}
				return structureTree.getStyle('defaultLeafIcon');
			}
			
			private function viewList_iconFunc(item:XML):Class {
				var type:String = item.@type;
				switch (type) {
					case 'dsl_show': return FlexGlobals.topLevelApplication.decoratorIcon;
					case 'dsl_text': return FlexGlobals.topLevelApplication.documentIcon;
					case 'dsl_table': return FlexGlobals.topLevelApplication.tableIcon;						
					case 'dsl_table_row': return FlexGlobals.topLevelApplication.tableRowIcon;						
					case 'dsl_table_column': return FlexGlobals.topLevelApplication.tableColumnIcon;						
				}
				return structureTree.getStyle('defaultLeafIcon');
			}
			
			private function nodeLabel(item:XML):String {
				if (item.hasOwnProperty("@name")) {
					return item.@name
				}
				else return item.localName();
			}
			
			
			private function mouseDownStructuralElements(event:MouseEvent):void {
				dragSourceSelectedItem = Vtree.selectedItem as XML;
			}
			
			
			private function mouseDownStructureTree(event:MouseEvent):void {
				dragSourceSelectedItem = structureTree.selectedItem as XML;
			}
			
			private function toggleDataTips(event:MouseEvent):void {
				var b:Boolean = !structureTree.showDataTips;
				structureTree.showDataTips = b;
				ToolTipManager.enabled = !ToolTipManager.enabled;
			}
		]]>     
	</mx:Script>

	<mx:VBox width="100%" height="100%">
		<mx:HBox width="100%">
			
			<mx:Grid width="80%">
				<mx:GridRow>
					<mx:GridItem>
						<mx:Label text="Name:"/>
					</mx:GridItem>
					<mx:GridItem>
						<mx:TextInput id="View_name" text="{_viewXML.@name}" change="nameUpdate()"/>	
					</mx:GridItem>					
				</mx:GridRow>
				<mx:GridRow>
					<mx:GridItem>
						<mx:Label text="Description:"/>
					</mx:GridItem>
					<mx:GridItem>
						<mx:TextArea id="View_description" text="{_viewXML.@description}" change="descriptionUpdate()"/>	
					</mx:GridItem>	
					
				</mx:GridRow>
				
			</mx:Grid>
			
			
		</mx:HBox>
		
		
		<mx:TabNavigator width="100%" height="100%" creationPolicy="all" >
			<mx:VBox id="viewEditorBox" width="100%" height="100%" label="Structure editor">
				<mx:HBox width="100%">
					<mx:Spacer width="100%"/>
					<mx:Button id="viewEditorHelpButton" label="Help" click="viewEditorHelp(event)" toolTip="Get help on creating a view."/>
					<mx:CheckBox label="Tips" click="toggleDataTips(event)" toolTip="Toggle tips." selected="true"/>
				</mx:HBox>
				<mx:HBox width="100%" height="100%">						
					<mx:HBox width="100%" height="100%">
						<lexus:AutoSizeTree id="structureTree" dataProvider="{_viewXML.structure as XMLList}"
											width="100%" height="100%" 
											editable="false" rowHeight="24"
											showRoot="true" labelFunction="nodeLabel"
											mouseDown="mouseDownStructureTree(event)"
											dragEnabled="true" dropEnabled="true"	
											dragOver="doDragOver(event)"
											dragExit="doDragExit(event)"
											dragEnter="dragEnterHandler(event);"
											dragDrop="dragDropHandler(event);"
											dragComplete="doDragComplete(event)"
											doubleClickEnabled="true" doubleClick="changeHandler(event)"
											itemRenderer="nl.mpi.lexus.view.NodeRenderer"
											keyUp="onKeyUp(event);"
											showDataTips="true"
											dataTipFunction="dataTips"
											iconFunction="viewTree_iconFunc"
											toolTip="Define your view using decorators, tables, text and data catagory and container elements from your lexicon."
											/>
					</mx:HBox>
					<mx:Panel width="20%" height="100%" id="StructEltsPanel" title="Structural elements">
						<mx:Tree id="Vtree" dataProvider="{new XMLListCollection(viewElements.*)}"
								 dragEnabled="true" dragMoveEnabled="false"
								 mouseDown="mouseDownStructuralElements(event)"
								 width="100%" height="96%" labelField="@label"
								 iconFunction="viewList_iconFunc"/>
					</mx:Panel>
					<mx:TextArea id="help" width="100%" height="100%" visible="false" includeInLayout="false" editable="false"/>
				</mx:HBox>
			</mx:VBox>
			<mx:VBox id="styleEditorBox" width="100%" height="100%" label="Style editor" click="initializeStyleEditor(event)">
				<mx:HBox width="100%">
					<mx:Spacer width="100%"/>
					<mx:Button id="addStylesButton" label="Add styles for classes" click="addStylesForClasses(event)" toolTip="Add style definitions for classes you have used in your view."/>
					<mx:Button id="stylesHelpButton" label="Help with styles" click="stylesHelp(event)" toolTip="Get more info on styling your lexical entries using CSS."/>
				</mx:HBox>
				<mx:HBox width="100%" height="100%">					
					<mx:TextArea id="styleEditor" width="100%" height="100%" toolTip="Click '{stylesHelpButton.label}' for help on styling." text="{_viewXML.style}" change="updateStyleInViewXML();"/>
					<mx:TextArea id="styleHelp" width="100%" height="100%" visible="false" includeInLayout="false" editable="false"/>
				</mx:HBox>
			</mx:VBox>
		</mx:TabNavigator>
	</mx:VBox>
</mx:Panel>
